<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Quilkin Book</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Quickstart</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="quickstart-netcat.html"><strong aria-hidden="true">2.1.</strong> Netcat</a></li><li class="chapter-item expanded "><a href="quickstart-agones-xonotic.html"><strong aria-hidden="true">2.2.</strong> Agones + Xonotic</a></li></ol></li><li class="chapter-item expanded "><a href="using.html"><strong aria-hidden="true">3.</strong> Usage</a></li><li class="chapter-item expanded "><a href="examples.html"><strong aria-hidden="true">4.</strong> Examples</a></li><li class="chapter-item expanded "><a href="session.html"><strong aria-hidden="true">5.</strong> Session</a></li><li class="chapter-item expanded "><a href="proxy.html"><strong aria-hidden="true">6.</strong> Proxy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="proxy-configuration.html"><strong aria-hidden="true">6.1.</strong> Proxy Configuration</a></li></ol></li><li class="chapter-item expanded "><a href="filters.html"><strong aria-hidden="true">7.</strong> Filters</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="filters/capture_bytes.html"><strong aria-hidden="true">7.1.</strong> Capture Bytes</a></li><li class="chapter-item expanded "><a href="filters/concatenate_bytes.html"><strong aria-hidden="true">7.2.</strong> Concatenate Bytes</a></li><li class="chapter-item expanded "><a href="filters/compress.html"><strong aria-hidden="true">7.3.</strong> Compress</a></li><li class="chapter-item expanded "><a href="filters/debug.html"><strong aria-hidden="true">7.4.</strong> Debug</a></li><li class="chapter-item expanded "><a href="filters/load_balancer.html"><strong aria-hidden="true">7.5.</strong> Load Balancer</a></li><li class="chapter-item expanded "><a href="filters/local_rate_limit.html"><strong aria-hidden="true">7.6.</strong> Local Rate Limit</a></li><li class="chapter-item expanded "><a href="filters/token_router.html"><strong aria-hidden="true">7.7.</strong> Token Router</a></li><li class="chapter-item expanded "><a href="filters/firewall.html"><strong aria-hidden="true">7.8.</strong> Firewall</a></li><li class="chapter-item expanded "><a href="filters/writing_custom_filters.html"><strong aria-hidden="true">7.9.</strong> Writing Custom Filters</a></li></ol></li><li class="chapter-item expanded "><a href="integrations.html"><strong aria-hidden="true">8.</strong> Integrations</a></li><li class="chapter-item expanded "><a href="admin.html"><strong aria-hidden="true">9.</strong> Administration</a></li><li class="chapter-item expanded "><a href="faq.html"><strong aria-hidden="true">10.</strong> FAQ</a></li><li class="chapter-item expanded "><a href="xds.html"><strong aria-hidden="true">11.</strong> xDS</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Quilkin Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>Quilkin is a UDP proxy, specifically designed for use with multiplayer dedicated game servers.</p>
<h2 id="what-is-quilkin"><a class="header" href="#what-is-quilkin">What is Quilkin?</a></h2>
<p>Quilkin on open source is a non-transparent UDP proxy specifically designed for use with large scale multiplayer
dedicated game servers deployments, to ensure security, access control, telemetry data, metrics and more.</p>
<p>It is designed to be used behind game clients as well as in front of dedicated game servers.</p>
<p>Quilkin's aim is to pull the above functionality out of bespoke, monolithic dedicated game servers and clients, and
provide standard, composable modules that can be reused across a wide set of multiplayer games, so that game
developers can instead focus on their game specific aspects of building a multiplayer game.</p>
<h2 id="why-use-quilkin"><a class="header" href="#why-use-quilkin">Why use Quilkin?</a></h2>
<p>Some of Quilkin's advantages:</p>
<ul>
<li>Lower development and operational costs for securing, monitoring and making reliable multiplayer game servers and
their communications.</li>
<li>Provide entry-point redundancy for your game clients to connect to - making it much harder to take down your game
servers.</li>
<li>Multiple integration patterns, allowing you to choose the level of integration that makes sense for your
architecture.</li>
<li>Remove non-game specific computation out of your game server's processing loop - and save that precious CPU for
your game simulation!</li>
</ul>
<h2 id="major-features"><a class="header" href="#major-features">Major Features</a></h2>
<p>Quilkin incorporates these abilities:</p>
<ul>
<li>Non-transparent proxying of UDP data, the internal state of your game architecture is not visible to bad actors.</li>
<li>Out of the box metrics for UDP packet information.</li>
<li>Composable tools for access control and security.</li>
<li>Able to be utilised as a standalone binary, with no client/server changes required or as a Rust library
depending on how deep an integration you wish for your system.</li>
<li>Can be integrated with C/C++ code bases via FFI.</li>
</ul>
<h2 id="what-next"><a class="header" href="#what-next">What Next?</a></h2>
<ul>
<li>Read the <a href="./using.html">usage guide</a></li>
<li>Have a look at the <a href="https://github.com/googleforgames/quilkin/blob/main/examples">example configurations</a> for basic configuration examples.</li>
<li>Check out the <a href="./integrations.html">example integration patterns</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quickstart-quilkin-with-netcat"><a class="header" href="#quickstart-quilkin-with-netcat">Quickstart: Quilkin with netcat</a></h1>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<ul>
<li>A *nix terminal</li>
<li>A binary release of Quilkin from the <a href="https://github.com/googleforgames/quilkin/releases">Github releases page</a> or by running <code>cargo install quilkin</code></li>
<li><a href="https://nmap.org/ncat/guide/">ncat</a></li>
<li><a href="http://netcat.sourceforge.net/">netcat</a></li>
</ul>
<h2 id="1-start-an-udp-echo-service"><a class="header" href="#1-start-an-udp-echo-service">1. Start an udp echo service</a></h2>
<p>So that we have a target for sending UDP packets to, let's use <code>ncat</code> to create a simple UDP echo process.</p>
<p>To do this run:</p>
<pre><code class="language-shell">ncat -e $(which cat) -k -u -l 8000
</code></pre>
<p>This routes all UDP packets that <code>ncat</code> receives to the local <code>cat</code> process, which echoes it back.</p>
<h2 id="2-start-quilkin"><a class="header" href="#2-start-quilkin">2. Start Quilkin</a></h2>
<p>Next, let's configure Quilkin, with a static configuration that points at the udp echo service we just started.</p>
<p>Open a new terminal and copy the following to a file named <code>proxy.yaml</code>:</p>
<pre><code class="language-yaml">version: v1alpha1
static:
  endpoints:
    - address: 127.0.0.1:8000
</code></pre>
<p>This configuration will start Quilkin on the default port of 7000, and it will redirect all incoming UDP traffic to
a single endpoint of 127.0.0.1, port 8000.</p>
<p>Let's start Quilkin with the above configuration:</p>
<pre><code class="language-shell">quilkin run --config proxy.yaml
</code></pre>
<p>You should see an output like the following:</p>
<pre><code class="language-shell">$ quilkin run --config proxy.yaml
{&quot;msg&quot;:&quot;Starting Quilkin&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;ts&quot;:&quot;2021-04-25T19:27:22.535174615-07:00&quot;,&quot;source&quot;:&quot;run&quot;,&quot;version&quot;:&quot;0.1.0-dev&quot;}
{&quot;msg&quot;:&quot;Starting&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;ts&quot;:&quot;2021-04-25T19:27:22.535315827-07:00&quot;,&quot;source&quot;:&quot;server::Server&quot;,&quot;port&quot;:7000}
{&quot;msg&quot;:&quot;Starting admin endpoint&quot;,&quot;level&quot;:&quot;INFO&quot;,&quot;ts&quot;:&quot;2021-04-25T19:27:22.535550572-07:00&quot;,&quot;source&quot;:&quot;proxy::Admin&quot;,&quot;address&quot;:&quot;[::]:9091&quot;}
</code></pre>
<h2 id="3-send-a-packet"><a class="header" href="#3-send-a-packet">3. Send a packet!</a></h2>
<p>In (yet 😃) another shell, let's use netcat to send an udp packet.</p>
<p>Run the following to connect netcat to Quilkin's receiving port of 7000 via UDP (<code>-u</code>):</p>
<pre><code class="language-shell">nc -u 127.0.0.1 7000
</code></pre>
<p>Type the word &quot;test&quot; and hit enter, you should see it echoed back to you like so:</p>
<pre><code class="language-shell">nc -u 127.0.0.1 7000
test
test
</code></pre>
<p>Feel free to send even more packets, as many as you would like 👍.</p>
<p>Congratulations! You have successfully routed a UDP packet and back again with Quilkin!</p>
<p>What's next?</p>
<ul>
<li>Run through the <a href="./quickstart-agones-xonotic.html">Quilkin with Agones quickstart</a>.</li>
<li>Have a look at some of <a href="https://github.com/googleforgames/quilkin/blob/main/examples">the examples</a> we have.</li>
<li>Check out the <a href="./proxy-configuration.html">proxy configuration reference</a> to what other configuration options are
available.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quickstart-quilkin-with-agones-and-xonotic"><a class="header" href="#quickstart-quilkin-with-agones-and-xonotic">Quickstart: Quilkin with Agones and Xonotic</a></h1>
<h2 id="requirements-1"><a class="header" href="#requirements-1">Requirements</a></h2>
<ul>
<li>A terminal with <code>kubectl</code> installed</li>
<li>A local copy of the <a href="https://xonotic.org/">Xonotic</a> client</li>
<li>A running <a href="https://agones.dev/">Agones</a> Kubernetes cluster
<ul>
<li><a href="https://agones.dev/site/docs/installation/">Installation instructions</a></li>
<li>If you aren't familiar with Agones, we recommend working through their 
<a href="https://agones.dev/site/docs/getting-started/">Getting Started</a> guides.</li>
</ul>
</li>
</ul>
<h2 id="1-agones-fleet-with-quilkin"><a class="header" href="#1-agones-fleet-with-quilkin">1. Agones Fleet with Quilkin</a></h2>
<p>In this step, we're going to set up a Xonotic dedicated game server, with Quilkin running as a 
<a href="integrations.html#server-proxy-as-a-sidecar">sidecar</a>, which will give us access to all the
<a href="./proxy.html#metrics">metrics</a> that Quilkin provides.</p>
<pre><code class="language-shell">kubectl apply -f https://raw.githubusercontent.com/googleforgames/quilkin/main/examples/agones-xonotic/sidecar.yaml
</code></pre>
<p>This applies two resources to your cluster:</p>
<ol>
<li>A Kubernetes <a href="https://kubernetes.io/docs/concepts/configuration/configmap/">ConfigMap</a> with a basic Quilkin
static configuration.</li>
<li>An Agones <a href="https://agones.dev/site/docs/reference/fleet/">Fleet specification</a> with Quilkin running as a sidecar 
to Xonotic, such that it can process all the UDP traffic and pass it to the Xonotic dedicated game server.</li>
</ol>
<p>Now you can run <code>kubectl get gameservers</code> until all your Agones <code>GameServers</code> are marked as <code>Ready</code> like so:</p>
<pre><code class="language-shell">$ kubectl get gameservers
NAME                          STATE   ADDRESS         PORT   NODE                                    AGE
xonotic-sidecar-htc2x-84mzm   Ready   34.94.107.201   7533   gke-agones-default-pool-0f7d8adc-7w3c   7m25s
xonotic-sidecar-htc2x-sdp4k   Ready   34.94.107.201   7599   gke-agones-default-pool-0f7d8adc-7w3c   7m25s
</code></pre>
<h2 id="2-play-xonotic"><a class="header" href="#2-play-xonotic">2. Play Xonotic!</a></h2>
<p>Usually with Agones you would
<a href="https://agones.dev/site/docs/getting-started/create-fleet/#4-allocate-a-game-server-from-the-fleet">Allocate</a> a 
<code>GameServer</code>, but we'll skip this step for this example.</p>
<p>Choose one of the listed <code>GameServer</code>s from the previous step, and connect to the IP and port of the Xonotic 
server via the &quot;Multiplayer &gt; Address&quot; field in the Xonotic client in the format of {IP}:{PORT}.</p>
<p>You should now be playing a game of Xonotic against 4 bots!</p>
<h2 id="3-check-out-the-metrics"><a class="header" href="#3-check-out-the-metrics">3. Check out the metrics</a></h2>
<p>Let's take a look at some metrics that Quilkin outputs.</p>
<p>Grab the name of the GameServer you connected to before, and replace the <code>${gameserver}</code> value below, and run the 
command. This will forward the <a href="./admin.html">admin</a> interface to localhost.</p>
<pre><code class="language-shell">kubectl port-forward ${gameserver} 9091
</code></pre>
<p>Then open a browser to <a href="http://localhost:9091/metrics">http://localhost:9091/metrics</a> to see the 
<a href="https://prometheus.io/">Prometheus</a> metrics that Quilkin exports.</p>
<h2 id="5-cleanup"><a class="header" href="#5-cleanup">5. Cleanup</a></h2>
<p>Run the following to delete the Fleet and the accompanying ConfigMap:</p>
<pre><code class="language-shell">kubectl delete -f  https://raw.githubusercontent.com/googleforgames/quilkin/main/examples/agones-xonotic/sidecar.yaml
</code></pre>
<h2 id="6-agones-fleet-but-with-compression"><a class="header" href="#6-agones-fleet-but-with-compression">6. Agones Fleet, but with Compression</a></h2>
<p>Let's take this one step further and compress the data between the Xonotic client and the server, without having to 
change either of them!</p>
<p>Let's create a new Xonotic Fleet on our Agones cluster, but this time configured such that Quilkin will decompress 
packets that are incoming.</p>
<p>Run the following:</p>
<pre><code class="language-shell">kubectl apply -f https://raw.githubusercontent.com/googleforgames/quilkin/main/examples/agones-xonotic/sidecar-compress.yaml
</code></pre>
<p>This will implement the <a href="./filters/compress.html">Compress</a> filter in our Quilkin sidecar proxy in our new 
Fleet.</p>
<p>Now you can run <code>kubectl get gameservers</code> until all your Agones <code>GameServers</code> are marked as <code>Ready</code> like so:</p>
<pre><code class="language-shell">$ kubectl get gameservers
NAME                                   STATE   ADDRESS         PORT   NODE                                    AGE
xonotic-sidecar-compress-htc2x-84mzm   Ready   34.94.107.201   7534   gke-agones-default-pool-0f7d8adc-7w3c   7m25s
xonotic-sidecar-compress-htc2x-sdp4k   Ready   34.94.107.201   7592   gke-agones-default-pool-0f7d8adc-7w3c   7m25s
</code></pre>
<h2 id="4-play-xonotic-through-quilkin"><a class="header" href="#4-play-xonotic-through-quilkin">4. Play Xonotic, through Quilkin</a></h2>
<p>What we will do in this step, is run Quilkin locally as a client-side proxy to compress the UDP data before it is 
sent up to our Xonotic servers that are expecting compressed data.</p>
<p>First, grab a copy of the Quilkin configuration 
<a href="https://github.com/googleforgames/quilkin/blob/main/examples/agones-xonotic/sidecar-compress.yaml">client-compress.yaml</a> 
locally. This has the Compress filter already configured, but we need to fill in the address to connect to.</p>
<blockquote>
<p>Rather than editing a file, this could also be sent through the <a href="./xds.html">xDS API</a>, but it is easier to 
demonstrate this functionality through a static configuration.</p>
</blockquote>
<p>Instead of connecting Xonotic directly, take the IP and port from one of the Agones hosted <code>GameServer</code> records, and 
replace the <code>${GAMESERVER_IP}</code> and <code>${GAMESERVER_PORT}</code> values in your copy of <code>client-compress.yaml</code>. </p>
<p>Run this configuration locally as:</p>
<pre><code class="language-shell">quilkin run -c ./client-compress.yaml`
</code></pre>
<p>Now we can connect to the local client proxy on &quot;127.0.0.1:7000&quot; via the &quot;Multiplayer &gt; Address&quot; field in the
Xonotic client, and Quilkin will take care of compressing the data for you without having to change the game
client!</p>
<p>Congratulations! You are now using Quilkin to manipulate the game client to server connection, without having to 
edit either!</p>
<h2 id="7-cleanup"><a class="header" href="#7-cleanup">7. Cleanup</a></h2>
<p>Run the following to delete the Fleet and the accompanying ConfigMap:</p>
<pre><code class="language-shell">kubectl delete -f https://raw.githubusercontent.com/googleforgames/quilkin/main/examples/agones-xonotic/sidecar-compress.yaml
</code></pre>
<h2 id="whats-next"><a class="header" href="#whats-next">What's Next?</a></h2>
<ul>
<li>Have a look at the <a href="https://github.com/googleforgames/quilkin/blob/main/examples">examples</a> folder for configuration and usage examples.</li>
<li>Explore the <a href="./proxy-configuration.html">proxy configuration reference</a> for other configuration options. </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-quilkin"><a class="header" href="#using-quilkin">Using Quilkin</a></h1>
<p>There are two choices for running Quilkin:</p>
<ul>
<li>Binary</li>
<li>Container image</li>
</ul>
<p>For each version there is both a release version, which is optimised for production usage, and a debug version that 
has debug level logging enabled.</p>
<h2 id="binary"><a class="header" href="#binary">Binary</a></h2>
<p>The release binary can be downloaded from the 
<a href="https://github.com/googleforgames/quilkin/releases">Github releases page</a>.</p>
<p>Quilkin needs to be run with an accompanying <a href="./proxy-configuration.html">configuration file</a>, like so:</p>
<p><code>quilkin run --config=&quot;configuration.yaml&quot;</code></p>
<p>To view debug output, run the same command with the <code>quilkin-debug</code> binary.</p>
<p>You can also use the shorthand of <code>-c</code> instead of <code>--config</code> if you so desire.</p>
<h2 id="container-image"><a class="header" href="#container-image">Container Image</a></h2>
<p>For each release, there are both a release and debug container image built and hosted on Google Cloud 
<a href="https://cloud.google.com/artifact-registry">Artifact Registry</a> listed for 
each <a href="https://github.com/googleforgames/quilkin/releases">release</a>.</p>
<p>The production release can be found under the tag: </p>
<p><code>us-docker.pkg.dev/quilkin/release/quilkin:{version}</code></p>
<p>Whereas, if you need debugging logging, use the following tag:</p>
<p><code>us-docker.pkg.dev/quilkin/release/quilkin:{version}-debug</code></p>
<p>Mount your <a href="./proxy-configuration.html">configuration file</a> at <code>/etc/quilkin/quilkin.yaml</code> to configure the Quilkin 
instance inside the container.</p>
<p>A <a href="https://github.com/googleforgames/quilkin/blob/main/image/quilkin.yaml">default configuration</a>
is provided, such the container will start without a new configuration file, but it is configured to point to 
<code>127.0.0.1:0</code> as a no-op configuration.</p>
<p>What's next:</p>
<ul>
<li>Run through the <a href="./quickstart-netcat.html">netcat with Quilkin quickstart</a></li>
<li>Review our <a href="./integrations.html">example integration architectures</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<p>See the <a href="https://github.com/googleforgames/quilkin/tree/main/examples">examples</a> folder on Github for configuration and 
usage examples.</p>
<blockquote>
<p>Depending on which release version of Quilkin you are using, you may need to choose the appropriate release tag
from the dropdown, as the API surface for Quilkin is still under development.</p>
</blockquote>
<p>Examples include:</p>
<ul>
<li>Quilkin running as a sidecar while hosted on <a href="https://agones.dev/">Agones</a>.</li>
<li><a href="https://iperf.fr/">iperf3</a> throughput.</li>
<li><a href="https://grafana.com/">Grafana</a> dashboards.</li>
</ul>
<p>...and more!</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="session"><a class="header" href="#session">Session</a></h3>
<p>Quilkin uses the <code>Session</code> concept to track traffic flowing through the proxy between any client-server pair. A Session serves the same purpose, and can be thought of as a lightweight version of a <code>TCP</code> session in that, while a TCP session requires a protocol to establish and teardown:</p>
<ul>
<li>A Quilkin session is automatically created upon receiving the first packet from the client, to be sent to an upstream server.</li>
<li>The session is automatically torn down after a period of inactivity (where no packet was sent between either party) - currently 60 seconds.</li>
</ul>
<p>A session is identified by the 4-tuple <code>(client IP, client Port, server IP, server Port)</code> where the client is the downstream endpoint which initiated the communication with Quilkin and the server is one of the upstream endpoints that Quilkin proxies traffic to.</p>
<p>Sessions are established <em>after</em> the filter chain completes. The destination endpoint of a packet is determined by the filter chain, so a session can only be created after filter chain completion. For example, if the filter chain drops all packets, then no session will ever be created.</p>
<h4 id="metrics"><a class="header" href="#metrics">Metrics</a></h4>
<p>The proxy exposes the following metrics around sessions:</p>
<ul>
<li>
<p><code>quilkin_session_active</code> (Gauge)</p>
<p>The number of currently active sessions.</p>
</li>
<li>
<p><code>quilkin_session_duration_secs</code> (Histogram)</p>
<p>A histogram over how long sessions lasted before they were torn down. Note that, by definition, active sessions are not included in this metric.</p>
</li>
<li>
<p><code>quilkin_session_total</code> (Counter)</p>
<p>The total number of sessions that have been created.</p>
</li>
<li>
<p><code>quilkin_session_rx_bytes_total</code> (Counter)</p>
<p>The total number of bytes received from the upstream endpoint.</p>
</li>
<li>
<p><code>quilkin_session_rx_bytes_total</code> (Counter)</p>
<p>The total number of bytes sent to the upstream endpoint.</p>
</li>
<li>
<p><code>quilkin_session_rx_packets_total</code> (Counter)</p>
<p>The total number of packets received from the upstream endpoint.</p>
</li>
<li>
<p><code>quilkin_session_tx_packets_total</code> (Counter)</p>
<p>The total number of packets sent to the upstream endpoint.</p>
</li>
<li>
<p><code>quilkin_session_packets_dropped_total</code> (Counter)</p>
<p>The total number of packets received from the upstream endpoint which were dropped by the filter chain rather than forwarded to the downstream endpoint.</p>
</li>
<li>
<p><code>quilkin_session_rx_errors_total</code> (Counter)</p>
<p>The total number of errors encountered while reading a packet from the upstream endpoint.</p>
</li>
<li>
<p><code>quilkin_session_rx_errors_total</code> (Counter)</p>
<p>The total number of errors encountered while sending a packet to the upstream endpoint.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="proxy"><a class="header" href="#proxy">Proxy</a></h3>
<h4 id="concepts"><a class="header" href="#concepts">Concepts</a></h4>
<h5 id="upstream-endpoint"><a class="header" href="#upstream-endpoint">Upstream Endpoint</a></h5>
<p>An Upstream Endpoint represents a server that Quilkin forwards packets to.
It is represented by an IP address and port. An upstream endpoint can optionally be associated with a (potentially empty) set of tokens as well as metadata.</p>
<h6 id="endpoint-metadata"><a class="header" href="#endpoint-metadata">Endpoint Metadata</a></h6>
<p>Arbitrary key value pairs that are associated with the endpoint.
These are visible to Filters when processing packets and can be used to provide more context about endpoints (e.g whether or not to route a packet to an endpoint).
Keys must be of type string otherwise the configuration is rejected.</p>
<p>Metadata associated with an endpoint contain arbitrary key value pairs which <a href="./filters.html">Filters</a> can consult when processing packets (e.g they can contain information that determine whether or not to route a particular packet to an endpoint).</p>
<p>In fact, the tokens associated with an endpoint are simply a special piece of metadata well known to Quilkin and is used by the built-in <a href="./filters/token_router.html">TokenRouter</a> filter to route packets.
Such well known values are placed within an object in the endpoint metadata, under the special key <code>quilkin.dev</code>. Currently, only the <code>tokens</code> entry is in use.</p>
<p>As an example, the following shows the configuration for an endpoint with its metadata:</p>
<pre><code class="language-yaml">static:
  endpoints:
    - address: 127.0.0.1:26000
      metadata:
        canary: false
        quilkin.dev: # This object is extracted by Quilkin and is usually reserved for built-in features
          tokens:
            - MXg3aWp5Ng== # base64 for 1x7ijy6
            - OGdqM3YyaQ== # base64 for 8gj3v2i
</code></pre>
<p>An endpoint's metadata can be specified alongside the endpoint in <a href="./proxy-configuration.html">static configuration</a> or using the <a href="https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/endpoint/v3/endpoint_components.proto#envoy-v3-api-field-config-endpoint-v3-lbendpoint-metadata">xDS endpoint metadata</a> field when using <a href="./xds.html">dynamic configuration</a> via xDS.</p>
<h5 id="session-1"><a class="header" href="#session-1">Session</a></h5>
<p>A session represents ongoing communication flow between a client and an <a href="proxy.html#upstream-endpoint">Upstream Endpoint</a>. See the <a href="./session.html">Session documentation</a> for more information.</p>
<h4 id="metrics-1"><a class="header" href="#metrics-1">Metrics</a></h4>
<p>The proxy exposes the following general metrics (See the metrics sub-sections for metrics specific to other Quilkin components, e.g for metrics related to packet flow see <a href="./session.html#metrics">sessions metrics</a>, or metrics exported by individual filters can be found in the documentation for each filter):</p>
<ul>
<li>
<p><code>quilkin_proxy_packets_dropped_total{reason}</code> (Counter)</p>
<p>The total number of packets (not associated with any session) that were dropped by proxy.
Not that packets reflected by this metric were dropped at an earlier stage before they were associated with any session. For session based metrics, see the list of <a href="./session.html#metrics">session metrics</a> instead.</p>
<ul>
<li><code>reason = NoConfiguredEndpoints</code>
<ul>
<li><code>NoConfiguredEndpoints</code>: No upstream endpoints were available to send the packet to. This can occur e.g if the endpoints cluster was scaled down to zero and the proxy is configured via a control plane.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>quilkin_cluster_active</code> (Gauge)</p>
<p>The number of currently active clusters.</p>
</li>
<li>
<p><code>quilkin_cluster_active_endpoints</code> (Gauge)</p>
<p>The number of currently active upstream endpoints. Note that this tracks the number of endpoints that the proxy knows of rather than those that it is connected to (see <a href="./session.html#metrics">Session Metrics</a> instead for those)</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><p>Proxy Configuration</p>
<p>The following is the schema and reference for a Quilkin proxy configuration file. See the <a href="https://github.com/googleforgames/quilkin/blob/main/examples">examples</a> folder for 
example configuration files.</p>
<p>By default Quilkin will look for a configuration file named <code>quilkin.yaml</code> in its current running directory first, 
then if not present, in <code>/etc/quilkin/quilkin.yaml</code> on UNIX systems. This can be overridden with the 
<code>-c/--config</code> command-line argument, or the <code>QUILKIN_FILENAME</code> environment variable.</p>
<pre><code class="language-yaml">type: object
properties:
  version:
    type: string
    description: |
      The configuration file version to use.
    enum:
      - v1alpha1
  proxy:
    type: object
    description: |
      Configuration of core proxy behavior.
    properties:
      id:
        type: string
        description: |
          An identifier for the proxy instance.
        default: On linux, the machine hostname is used as default. On all other platforms a UUID is generated for the proxy.
      port:
        type: integer
        description: |
          The listening port for the proxy.
        default: 7000
  admin:
    type: object
    description: |
      Configuration of proxy admin HTTP interface.
    properties:
      address:
      type: string
      description: |
        Socket Address and port to bind the administration interface to.
      default: [::]:9091
  static:
    type: object
    description: |
      Static configuration of endpoints and filters.
      NOTE: Exactly one of `static` or `dynamic` can be specified.
    properties:
      filter:
        '$ref': '#/definitions/filterchain'
      endpoints:
        '$ref': '#/definitions/endpoints'
    required:
      - endpoints
  dynamic:
    type: object
    description: |
      Dynamic configuration of endpoints and filters.
      NOTE: Exactly one of `static` or `dynamic` can be specified.
    properties:
      management_servers:
        type: array
        description: |
          A list of XDS management servers to fetch configuration from.
          Multiple servers can be provided for redundancy for the proxy to
          fall back to upon error.
        items:
          type: object
            description: |
              Configuration for a management server.
            properties:
              address:
                type: string
                description: |
                  Address of the management server. This must have the `http(s)` scheme prefix.
                  Example: `http://example.com`
    required:
      - management_servers

required:
  - version

definitions:
  filterchain:
    type: array
    description: |
      A filter chain.
    items:
      '$ref': {} # Refer to the Filter documentation for a filter configuration schema.
  endpoints:
    type: array
    description: |
      A list of upstream endpoints to forward packets to.
    items:
      type: object
        description: |
          An upstream endpoint
        properties:
          address:
            type: string
            description: |
              Socket address of the endpoint. This must be of the ´IP:Port` form e.g `192.168.1.1:7001`
            metadata:
              type: object
              description: |
                Arbitrary key value pairs that is associated with the endpoint.
                These are visible to Filters when processing packets and can be used to provide more context about endpoints (e.g whether or not to route a packet to an endpoint).
                Keys must be of type string otherwise the configuration is rejected.
      required:
        - address
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="filters"><a class="header" href="#filters">Filters</a></h1>
<p>In most cases, we would like Quilkin to do some preprocessing of received packets before sending them off to their destination. Because this stage is entirely specific to the use case at hand and differs between Quilkin deployments, we must have a say over what tweaks to perform - this is where filters come in.</p>
<h3 id="filters-and-filter-chain"><a class="header" href="#filters-and-filter-chain">Filters and Filter chain</a></h3>
<p>A filter represents a step in the tweaking/decision-making process of how we would like to process our packets. For example, at some step, we might choose to append some metadata to every packet we receive before forwarding it while at a later step, choose not to forward packets that don't meet some criteria.</p>
<p>Quilkin lets us specify any number of filters and connect them in a sequence to form a packet processing pipeline similar to a <a href="https://en.wikipedia.org/wiki/Pipeline_(Unix)" target="_blank">Unix pipeline</a> - we call this pipeline a <code>Filter chain</code>. The combination of filters and filter chain allows us to add new functionality to fit every scenario without changing Quilkin's core.</p>
<p>As an example, say we would like to perform the following steps in our processing pipeline to the packets we receive.</p>
<ul>
<li>Append a predetermined byte to the packet.</li>
<li>Compress the packet.</li>
<li>Do not forward (drop) the packet if its compressed length is over 512 bytes.</li>
</ul>
<p>We would create a filter corresponding to each step either by leveraging any <a href="filters.html#built-in-filters">existing filters</a>
that do what we want or <a href="./filters/writing_custom_filters.html">writing one ourselves</a> and connect them to form the 
following filter chain:</p>
<pre><code class="language-bash">append | compress | drop
</code></pre>
<p>When Quilkin consults our filter chain, it feeds the received packet into <code>append</code> and forwards the packet it receives (if any) from <code>drop</code> - i.e the output of <code>append</code> becomes the <code>input</code> into <code>compress</code> and so on in that order.</p>
<p>There are a few things we note here:</p>
<ul>
<li>
<p>Although we have in this example, a filter called <code>drop</code>, every filter in the filter chain has the same ability to <em>drop</em> or <em>update</em> a packet - if any filter drops a packet then no more work needs to be done regarding that packet so the next filter in the pipeline never has any knowledge that the dropped packet ever existed.</p>
</li>
<li>
<p>The filter chain is consulted for every received packet, and its filters are traversed in reverse order for packets travelling in the opposite direction.
A packet received downstream will be fed into <code>append</code> and the result from <code>drop</code> is forwarded upstream - a packet received upstream will be fed into <code>drop</code> and the result from <code>append</code> is forwarded downstream.</p>
</li>
<li>
<p>Exactly one filter chain is specified and used to process all packets that flow through Quilkin.</p>
</li>
</ul>
<p><strong>Metrics</strong></p>
<ul>
<li>
<p><code>quilkin_filter_read_duration_seconds</code> The duration it took for a <code>filter</code>'s
<code>read</code> implementation to execute.</p>
<ul>
<li>Labels
<ul>
<li><code>filter</code> The name of the filter being executed.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>quilkin_filter_write_duration_seconds</code> The duration it took for a <code>filter</code>'s
<code>write</code> implementation to execute.</p>
<ul>
<li>Labels
<ul>
<li><code>filter</code> The name of the filter being executed.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="configuration-examples"><a class="header" href="#configuration-examples">Configuration Examples</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">// Wrap this example within an async main function since the
</span><span class="boring">// local_rate_limit filter spawns a task on initialization
</span><span class="boring">#[tokio::main]
</span><span class="boring">async fn main() {
</span><span class="boring">let yaml = &quot;
</span>version: v1alpha1
static:
  filters:
    - name: quilkin.extensions.filters.debug.v1alpha1.Debug
      config:
        id: debug-1
    - name: quilkin.extensions.filters.local_rate_limit.v1alpha1.LocalRateLimit
      config:
        max_packets: 10
        period: 1
  endpoints:
    - address: 127.0.0.1:7001
<span class="boring">&quot;;
</span><span class="boring">let config = quilkin::config::Config::from_reader(yaml.as_bytes()).unwrap();
</span><span class="boring">assert_eq!(config.source.get_static_filters().unwrap().len(), 2);
</span><span class="boring">quilkin::Builder::from(std::sync::Arc::new(config)).validate().unwrap();
</span><span class="boring">}
</span></code></pre></pre>
<p>We specify our filter chain in the <code>.filters</code> section of the proxy's configuration which has takes a sequence of <a href="filters.html#filter-config">FilterConfig</a> objects. Each object describes all information necessary to create a single filter.</p>
<p>The above example creates a filter chain comprising a <a href="./filters/debug.html">Debug</a> filter followed by a <a href="./filters/local_rate_limit.html">LocalRateLimit</a> filter - the effect is that every packet will be logged and the proxy will not forward more than 10 packets per second.</p>
<blockquote>
<p>The sequence determines the filter chain order so its ordering matters - the chain starts with the filter corresponding the first filter config and ends with the filter corresponding the last filter config in the sequence.</p>
</blockquote>
<h3 id="filter-dynamic-metadata"><a class="header" href="#filter-dynamic-metadata">Filter Dynamic Metadata</a></h3>
<p>A filter within the filter chain can share data within another filter further along in the filter chain by propagating the desired data alongside the packet being processed.
This enables sharing dynamic information at runtime, e.g information about the current packet that might be useful to other filters that process that packet.</p>
<p>At packet processing time each packet is associated with <em>filter dynamic metadata</em> (a set of key-value pairs). Each key is a unique string while its value is an associated <a href="../api/quilkin/metadata/enum.Value.html"><code>quilkin::metadata::Value</code></a>.
When a filter processes a packet, it can choose to consult the associated dynamic metadata for more information or itself add/update or remove key-values from the set.</p>
<p>As an example, the built-in <a href="./filters/capture_bytes.html">CaptureBytes</a> filter is one such filter that populates a packet's filter metadata.
<a href="./filters/capture_bytes.html">CaptureBytes</a> extracts information (a configurable byte sequence) from each packet and appends it to the packet's dynamic metadata for other filters to leverage.
On the other hand, the built-in <a href="./filters/token_router.html">TokenRouter</a> filter selects what endpoint to route a packet by consulting the packet's dynamic metadata for a routing token.
Consequently, we can build a filter chain with a <a href="./filters/capture_bytes.html">CaptureBytes</a> filter preceeding a <a href="./filters/token_router.html">TokenRouter</a> filter, both configured to write and read the same key in the dynamic metadata entry. The effect would be that packets are routed to upstream endpoints based on token information extracted from their contents.</p>
<h4 id="well-known-dynamic-metadata"><a class="header" href="#well-known-dynamic-metadata">Well Known Dynamic Metadata</a></h4>
<p>The following metadata are currently used by Quilkin core and built-in filters.</p>
<table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>quilkin.dev/captured_bytes</code></td><td><code>Bytes</code></td><td>The default key under which the <a href="./filters/capture_bytes.html">CaptureBytes</a> filter puts the byte slices it extracts from each packet.</td></tr>
</tbody></table>
<h3 id="built-in-filters-a-namebuilt-in-filtersa"><a class="header" href="#built-in-filters-a-namebuilt-in-filtersa">Built-in filters <a name="built-in-filters"></a></a></h3>
<p>Quilkin includes several filters out of the box.</p>
<table><thead><tr><th>Filter</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="./filters/debug.html">Debug</a></td><td>Logs every packet.</td></tr>
<tr><td><a href="./filters/local_rate_limit.html">LocalRateLimit</a></td><td>Limit the frequency of packets.</td></tr>
<tr><td><a href="./filters/concatenate_bytes.html">ConcatenateBytes</a></td><td>Add authentication tokens to packets.</td></tr>
<tr><td><a href="./filters/capture_bytes.html">CaptureBytes</a></td><td>Capture specific bytes from a packet and store them in <a href="filters.html#filter-dynamic-metadata">filter dynamic metadata</a>.</td></tr>
<tr><td><a href="./filters/token_router.html">TokenRouter</a></td><td>Send packets to endpoints based on metadata.</td></tr>
<tr><td><a href="./filters/compress.html">Compress</a></td><td>Compress and decompress packets data.</td></tr>
<tr><td><a href="./filters/firewall.html">Firewall</a></td><td>Allowing/blocking traffic by IP and port.</td></tr>
</tbody></table>
<h3 id="filterconfig-a-namefilter-configa"><a class="header" href="#filterconfig-a-namefilter-configa">FilterConfig <a name="filter-config"></a></a></h3>
<p>Represents configuration for a filter instance.</p>
<pre><code class="language-yaml">properties:
  name:
    type: string
    description: |
      Identifies the type of filter to be created.
      This value is unique for every filter type - please consult the documentation for the particular filter for this value.

  config:
    type: object
    description: |
      The configuration value to be passed onto the created filter.
      This is passed as an object value since it is specific to the filter's type and is validated by the filter
      implementation. Please consult the documentation for the particular filter for its schema.

required: [ 'name', 'config' ]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="capturebytes"><a class="header" href="#capturebytes">CaptureBytes</a></h1>
<p>The <code>CaptureBytes</code> filter's job is to find a series of bytes within a packet, and capture it into
<a href="filters/../filters.html#filter-dynamic-metadata">Filter Dynamic Metadata</a>, so that it can be utilised by filters further
down the chain.</p>
<p>This is often used as a way of retrieving authentication tokens from a packet, and used in combination with
<a href="filters/./concatenate_bytes.html">ConcatenateBytes</a> and 
<a href="filters/token_router.html">TokenRouter</a> filter to provide common packet routing utilities.</p>
<h4 id="filter-name"><a class="header" href="#filter-name">Filter name</a></h4>
<pre><code class="language-text">quilkin.extensions.filters.capture_bytes.v1alpha1.CaptureBytes
</code></pre>
<h3 id="configuration-examples-1"><a class="header" href="#configuration-examples-1">Configuration Examples</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let yaml = &quot;
</span>version: v1alpha1
static:
  filters:
    - name: quilkin.extensions.filters.capture_bytes.v1alpha1.CaptureBytes
      config:
          strategy: PREFIX
          metadataKey: myapp.com/myownkey
          size: 3
          remove: false
  endpoints:
    - address: 127.0.0.1:7001
<span class="boring">&quot;;
</span><span class="boring">let config = quilkin::config::Config::from_reader(yaml.as_bytes()).unwrap();
</span><span class="boring">assert_eq!(config.source.get_static_filters().unwrap().len(), 1);
</span><span class="boring">quilkin::Builder::from(std::sync::Arc::new(config)).validate().unwrap();
</span><span class="boring">}
</span></code></pre></pre>
<h3 id="configuration-options-a-hreffiltersapiquilkinfilterscapture_bytesstructconfightmlrust-doca"><a class="header" href="#configuration-options-a-hreffiltersapiquilkinfilterscapture_bytesstructconfightmlrust-doca">Configuration Options (<a href="filters/../../api/quilkin/filters/capture_bytes/struct.Config.html">Rust Doc</a>)</a></h3>
<pre><code class="language-yaml">properties:
  strategy:
    type: string
    description: |
      The selected strategy for capturing the series of bytes from the incoming packet.
       - SUFFIX: Retrieve bytes from the end of the packet.
       - PREFIX: Retrieve bytes from the beginnning of the packet.
    default: &quot;SUFFIX&quot;
    enum: ['PREFIX', 'SUFFIX']
  metadataKey:
    type: string
    default: quilkin.dev/captured_bytes
    description: | 
      The key under which the captured bytes are stored in the Filter invocation values.
  size:
    type: integer
    description: |
      The number of bytes in the packet to capture using the applied strategy.
  remove:
    type: boolean
    default: false
    description: |
      Whether or not to remove the captured bytes from the packet before passing it along to the next filter in the
      chain.
  required: ['size']
</code></pre>
<h3 id="metrics-2"><a class="header" href="#metrics-2">Metrics</a></h3>
<ul>
<li><code>quilkin_filter_CaptureBytes_packets_dropped</code><br />
A counter of the total number of packets that have been dropped due to their length being less than the configured
<code>size</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concatenatebytes"><a class="header" href="#concatenatebytes">ConcatenateBytes</a></h1>
<p>The <code>ConcatenateBytes</code> filter's job is to add a byte packet to either the beginning or end of each UDP packet that passes
through. This is commonly used to provide an auth token to each packet, so they can be routed appropriately.</p>
<h4 id="filter-name-1"><a class="header" href="#filter-name-1">Filter name</a></h4>
<pre><code class="language-text">quilkin.extensions.filters.concatenate_bytes.v1alpha1.ConcatenateBytes
</code></pre>
<h3 id="configuration-examples-2"><a class="header" href="#configuration-examples-2">Configuration Examples</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let yaml = &quot;
</span>version: v1alpha1
static:
  filters:
    - name: quilkin.extensions.filters.concatenate_bytes.v1alpha1.ConcatenateBytes
      config:
          on_read: APPEND
          on_write: DO_NOTHING
          bytes: MXg3aWp5Ng==
  endpoints:
    - address: 127.0.0.1:7001
<span class="boring">&quot;;
</span><span class="boring">let config = quilkin::config::Config::from_reader(yaml.as_bytes()).unwrap();
</span><span class="boring">assert_eq!(config.source.get_static_filters().unwrap().len(), 1);
</span><span class="boring">quilkin::Builder::from(std::sync::Arc::new(config)).validate().unwrap();
</span><span class="boring">}
</span></code></pre></pre>
<h3 id="configuration-options-a-hreffiltersapiquilkinfiltersconcatenate_bytesstructconfightmlrust-doca"><a class="header" href="#configuration-options-a-hreffiltersapiquilkinfiltersconcatenate_bytesstructconfightmlrust-doca">Configuration Options (<a href="filters/../../api/quilkin/filters/concatenate_bytes/struct.Config.html">Rust Doc</a>)</a></h3>
<pre><code class="language-yaml">properties:
  on_read:
    type: string
    description: |
      Either append or prepend the `bytes` data to each packet filtered on read of the listening port.
    default: DO_NOTHING
    enum: ['DO_NOTHING', 'APPEND', 'PREPEND']
  on_write:
    type: string
    description: |
      Either append or prepend the `bytes` data to each packet filtered on write of the listening port.
    default: DO_NOTHING
    enum: ['DO_NOTHING', 'APPEND', 'PREPEND']    
  bytes:
    type: string
    description: |
      Base64 encoded string of the byte array to add to each packet as it is filtered.
</code></pre>
<h3 id="metrics-3"><a class="header" href="#metrics-3">Metrics</a></h3>
<p>This filter currently exports no metrics.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compress"><a class="header" href="#compress">Compress</a></h1>
<p>The <code>Compress</code> filter's job is to provide a variety of compression implementations for compression 
and subsequent decompression of UDP data when sent between systems, such as a game client and game server.</p>
<h4 id="filter-name-2"><a class="header" href="#filter-name-2">Filter name</a></h4>
<pre><code class="language-text">quilkin.extensions.filters.compress.v1alpha1.Compress
</code></pre>
<h3 id="configuration-examples-3"><a class="header" href="#configuration-examples-3">Configuration Examples</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let yaml = &quot;
</span>version: v1alpha1
static:
  filters:
    - name: quilkin.extensions.filters.compress.v1alpha1.Compress
      config:
          on_read: COMPRESS
          on_write: DECOMPRESS
          mode: SNAPPY
  endpoints:
    - address: 127.0.0.1:7001
<span class="boring">&quot;;
</span><span class="boring">let config = quilkin::config::Config::from_reader(yaml.as_bytes()).unwrap();
</span><span class="boring">assert_eq!(config.source.get_static_filters().unwrap().len(), 1);
</span><span class="boring">quilkin::Builder::from(std::sync::Arc::new(config)).validate().unwrap();
</span><span class="boring">}
</span></code></pre></pre>
<p>The above example shows a proxy that could be used with a typical game client, where the original client data is 
sent to the local listening port and then compressed when heading up to a dedicated game server, and then 
decompressed when traffic is returned from the dedicated game server before being handed back to game client. </p>
<blockquote>
<p>It is worth noting that since the Compress filter modifies the <em>entire packet</em>, it is worth paying special
attention to the order it is placed in your <a href="filters/../filters.html">Filter configuration</a>. Most of the time it will likely be
the first or last Filter configured to ensure it is compressing the entire set of data being sent.</p>
</blockquote>
<h3 id="configuration-options-a-hreffiltersapiquilkinfilterscompressstructconfightmlrust-doca"><a class="header" href="#configuration-options-a-hreffiltersapiquilkinfilterscompressstructconfightmlrust-doca">Configuration Options (<a href="filters/../../api/quilkin/filters/compress/struct.Config.html">Rust Doc</a>)</a></h3>
<pre><code class="language-yaml">properties:
  on_read:
    '$ref': '#/definitions/action'
    description: |
      Whether to compress, decompress or do nothing when reading packets from the local listening port
  on_write:
    '$ref': '#/definitions/action'
    description: |
      Whether to compress, decompress or do nothing when writing packets to the local listening port
  mode:
    type: string
    description: |
      The compression implementation to use on the incoming and outgoing packets. See &quot;Compression Modes&quot; for details.
    enum:
      - SNAPPY
    default: SNAPPY

definitions:
  action:
    type: string
    enum:
      - DO_NOTHING
      - COMPRESS
      - DECOMPRESS
    default: DO_NOTHING
</code></pre>
<h4 id="compression-modes"><a class="header" href="#compression-modes">Compression Modes</a></h4>
<h5 id="snappy"><a class="header" href="#snappy">Snappy</a></h5>
<blockquote>
<p>Snappy is a compression/decompression library. It does not aim for maximum compression, or compatibility with any 
other compression library; instead, it aims for very high speeds and reasonable compression.</p>
</blockquote>
<p>Currently, this filter only provides the <a href="http://google.github.io/snappy/">Snappy</a> compression format via the
<a href="https://github.com/BurntSushi/rust-snappy">rust-snappy</a> crate, but more will be
provided in the future.</p>
<h3 id="metrics-4"><a class="header" href="#metrics-4">Metrics</a></h3>
<ul>
<li><code>quilkin_filter_Compress_packets_dropped_total</code>
Total number of packets dropped as they could not be processed.
<ul>
<li>Labels:
<ul>
<li><code>action</code>: The action that could not be completed successfully, thereby causing the packet to be dropped.
<ul>
<li><code>Compress</code>: Compressing the packet with the configured <code>mode</code> was attempted.</li>
<li><code>Decompress</code> Decompressing the packet with the configured <code>mode</code> was attempted.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><code>quilkin_filter_Compress_decompressed_bytes_total</code>
Total number of decompressed bytes either received or sent.</li>
<li><code>quilkin_filter_Compress_compressed_bytes_total</code>
Total number of compressed bytes either received or sent.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debug"><a class="header" href="#debug">Debug</a></h1>
<p>The Debug filter logs all incoming and outgoing packets to standard output.</p>
<p>This filter is useful in debugging deployments where the packets strictly contain valid <code>UTF-8</code> encoded strings. A generic error message is instead logged if conversion from bytes to <code>UTF-8</code> fails.</p>
<h4 id="filter-name-3"><a class="header" href="#filter-name-3">Filter name</a></h4>
<pre><code class="language-text">quilkin.extensions.filters.debug_filter.v1alpha1.Debug
</code></pre>
<h3 id="configuration-examples-4"><a class="header" href="#configuration-examples-4">Configuration Examples</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let yaml = &quot;
</span>version: v1alpha1
static:
  filters:
    - name: quilkin.extensions.filters.debug.v1alpha1.Debug
      config:
        id: debug-1
  endpoints:
    - address: 127.0.0.1:7001
<span class="boring">&quot;;
</span><span class="boring">let config = quilkin::config::Config::from_reader(yaml.as_bytes()).unwrap();
</span><span class="boring">assert_eq!(config.source.get_static_filters().unwrap().len(), 1);
</span><span class="boring">quilkin::Builder::from(std::sync::Arc::new(config)).validate().unwrap();
</span><span class="boring">}
</span></code></pre></pre>
<h3 id="configuration-options-a-hreffiltersapiquilkinfiltersdebugstructconfightmlrust-doca"><a class="header" href="#configuration-options-a-hreffiltersapiquilkinfiltersdebugstructconfightmlrust-doca">Configuration Options (<a href="filters/../../api/quilkin/filters/debug/struct.Config.html">Rust Doc</a>)</a></h3>
<pre><code class="language-yaml">properties:
  id:
    type: string
    description: |
      An identifier that will be included with each log message.
</code></pre>
<h3 id="metrics-5"><a class="header" href="#metrics-5">Metrics</a></h3>
<p>This filter currently exports no metrics.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loadbalancer"><a class="header" href="#loadbalancer">LoadBalancer</a></h1>
<p>The <code>LoadBalancer</code> filter distributes packets received downstream among all upstream endpoints.</p>
<h4 id="filter-name-4"><a class="header" href="#filter-name-4">Filter name</a></h4>
<pre><code class="language-text">quilkin.extensions.filters.load_balancer.v1alpha1.LoadBalancer
</code></pre>
<h3 id="configuration-examples-5"><a class="header" href="#configuration-examples-5">Configuration Examples</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[tokio::main]
</span><span class="boring">async fn main() {
</span><span class="boring">  let yaml = &quot;
</span>version: v1alpha1
static:
  filters:
    - name: quilkin.extensions.filters.load_balancer.v1alpha1.LoadBalancer
      config:
        policy: ROUND_ROBIN
  endpoints:
    - address: 127.0.0.1:7001
<span class="boring">&quot;;
</span><span class="boring">  let config = quilkin::config::Config::from_reader(yaml.as_bytes()).unwrap();
</span><span class="boring">assert_eq!(config.source.get_static_filters().unwrap().len(), 1);
</span><span class="boring">  quilkin::Builder::from(std::sync::Arc::new(config)).validate().unwrap();
</span><span class="boring">}
</span></code></pre></pre>
<p>The load balancing policy (the strategy to use to select what endpoint to send traffic to) is configurable.
In the example above, packets will be distributed by selecting endpoints in turn, in round robin fashion.</p>
<h3 id="configuration-options-a-hreffiltersapiquilkinfiltersload_balancerstructconfightmlrust-doca"><a class="header" href="#configuration-options-a-hreffiltersapiquilkinfiltersload_balancerstructconfightmlrust-doca">Configuration Options (<a href="filters/../../api/quilkin/filters/load_balancer/struct.Config.html">Rust Doc</a>)</a></h3>
<pre><code class="language-yaml">properties:
  policy:
    type: string
    description: |
      The load balancing policy with which to distribute packets among endpoints.
    enum:
      - ROUND_ROBIN # Send packets by selecting endpoints in turn.
      - RANDOM      # Send packets by randomly selecting endpoints.
      - HASH        # Send packets by hashing the source IP and port.
    default: ROUND_ROBIN
</code></pre>
<h3 id="metrics-6"><a class="header" href="#metrics-6">Metrics</a></h3>
<p>This filter currently does not expose any metrics.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="localratelimit"><a class="header" href="#localratelimit">LocalRateLimit</a></h1>
<p>The LocalRateLimit filter controls the frequency at which packets received downstream are forwarded upstream by the proxy.<br />
Rate limiting is done independently per source (IP, Port) combination.</p>
<h4 id="filter-name-5"><a class="header" href="#filter-name-5">Filter name</a></h4>
<pre><code class="language-text">quilkin.extensions.filters.local_rate_limit.v1alpha1.LocalRateLimit
</code></pre>
<h3 id="configuration-examples-6"><a class="header" href="#configuration-examples-6">Configuration Examples</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">// Wrap this example within an async main function since the
</span><span class="boring">// local_rate_limit filter spawns a task on initialization
</span><span class="boring">#[tokio::main]
</span><span class="boring">async fn main() {
</span><span class="boring">  let yaml = &quot;
</span>version: v1alpha1
static:
  filters:
    - name: quilkin.extensions.filters.local_rate_limit.v1alpha1.LocalRateLimit
      config:
        max_packets: 1000
        period: 1
  endpoints:
    - address: 127.0.0.1:7001
<span class="boring">&quot;;
</span><span class="boring">  let config = quilkin::config::Config::from_reader(yaml.as_bytes()).unwrap();
</span><span class="boring">assert_eq!(config.source.get_static_filters().unwrap().len(), 1);
</span><span class="boring">  quilkin::Builder::from(std::sync::Arc::new(config)).validate().unwrap();
</span><span class="boring">}
</span></code></pre></pre>
<p>To configure a rate limiter, we specify the maximum rate at which the proxy is allowed to forward packets. In the example above, we configured the proxy to forward a maximum of 1000 packets per second).</p>
<blockquote>
<p>Be aware that due to some optimizations in the current rate limiter implementation, the enforced maximum number of packets is not always exact.
It is in theory possible that the rate limiter allows a few packets through, however in practice this would be a rare occurrence
and the maximum number of such packets that is in the worse case <code>N-1</code> where <code>N</code> is the number of threads used to process packets.
For example, a configuration allowing 1000 packets per second could potentially allow 1004 packets during some time window if we have up to 4 threads.</p>
</blockquote>
<blockquote>
<p>Packets that that exceeds the maximum configured rate are dropped.</p>
</blockquote>
<h3 id="configuration-options-a-hreffiltersapiquilkinfilterslocal_rate_limitstructconfightmlrust-doca"><a class="header" href="#configuration-options-a-hreffiltersapiquilkinfilterslocal_rate_limitstructconfightmlrust-doca">Configuration Options (<a href="filters/../../api/quilkin/filters/local_rate_limit/struct.Config.html">Rust Doc</a>)</a></h3>
<pre><code class="language-yaml">properties:
  max_packets:
    type: integer
    description: |
      The maximum number of packets allowed to be forwarded over the given duration.
    minimum: 0

  period:
    type: string
    description: |
      The duration in seconds overwhich `max_packets` applies.
    default: 1 # 1 second
    minimum: 1

required: [ 'max_packets' ]
</code></pre>
<h3 id="metrics-7"><a class="header" href="#metrics-7">Metrics</a></h3>
<ul>
<li><code>quilkin_filter_LocalRateLimit_packets_dropped</code><br />
A counter over the total number of packets that have exceeded the configured maximum rate limit and have been dropped as a result.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tokenrouter"><a class="header" href="#tokenrouter">TokenRouter</a></h1>
<p>The <code>TokenRouter</code> filter's job is to provide a mechanism to declare which Endpoints a packet should be sent to.</p>
<p>This Filter provides this functionality by comparing a byte array token found in the
<a href="filters/../filters.html#filter-dynamic-metadata">Filter Dynamic Metadata</a> from a previous Filter, and comparing it to
<a href="filters/../proxy.html#upstream-endpoint">Endpoint's tokens</a>, and sending packets to those Endpoints only if there is a match.</p>
<h4 id="filter-name-6"><a class="header" href="#filter-name-6">Filter name</a></h4>
<pre><code class="language-text">quilkin.extensions.filters.token_router.v1alpha1.TokenRouter
</code></pre>
<h3 id="configuration-examples-7"><a class="header" href="#configuration-examples-7">Configuration Examples</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let yaml = &quot;
</span>version: v1alpha1
static:
  filters:
    - name: quilkin.extensions.filters.token_router.v1alpha1.TokenRouter
      config:
          metadataKey: myapp.com/myownkey
  endpoints: 
    - address: 127.0.0.1:26000
      metadata:
        quilkin.dev:
          tokens:
            - MXg3aWp5Ng== # Authentication is provided by these ids, and matched against 
            - OGdqM3YyaQ== # the value stored in Filter dynamic metadata
    - address: 127.0.0.1:26001
      metadata:
        quilkin.dev:
          tokens:
            - bmt1eTcweA==
<span class="boring">&quot;;
</span><span class="boring">let config = quilkin::config::Config::from_reader(yaml.as_bytes()).unwrap();
</span><span class="boring">assert_eq!(config.source.get_static_filters().unwrap().len(), 1);
</span><span class="boring">quilkin::Builder::from(std::sync::Arc::new(config)).validate().unwrap();
</span><span class="boring">}
</span></code></pre></pre>
<p>View the <a href="filters/./capture_bytes.html">CaptureBytes</a> filter documentation for more details.</p>
<h3 id="configuration-options-a-hreffiltersapiquilkinfilterstoken_routerstructconfightmlrust-doca"><a class="header" href="#configuration-options-a-hreffiltersapiquilkinfilterstoken_routerstructconfightmlrust-doca">Configuration Options (<a href="filters/../../api/quilkin/filters/token_router/struct.Config.html">Rust Doc</a>)</a></h3>
<pre><code class="language-yaml">properties:
  metadataKey:
    type: string
    default: quilkin.dev/captured_bytes
    description: | 
      The key under which the token is stored in the Filter dynamic metadata.
</code></pre>
<h3 id="metrics-8"><a class="header" href="#metrics-8">Metrics</a></h3>
<ul>
<li><code>quilkin_filter_TokenRouter_packets_dropped</code><br />
A counter of the total number of packets that have been dropped. This is also provided with a <code>Reason</code> label, as there
are differing reasons for packets to be dropped:
<ul>
<li><code>NoEndpointMatch</code> - The token provided via the Filter dynamic metadata does not match any Endpoint's tokens.</li>
<li><code>NoTokenFound</code> - No token has been found in the Filter dynamic metadata.</li>
<li><code>InvalidToken</code> - The data found for the token in the Filter dynamic metadata is not of the correct data type
(Vec<u8>)</li>
</ul>
</li>
</ul>
<h3 id="sample-applications"><a class="header" href="#sample-applications">Sample Applications</a></h3>
<h4 id="packet-authentication"><a class="header" href="#packet-authentication">Packet Authentication</a></h4>
<p>In combination with several other filters, the <code>TokenRouter</code> can be utilised as an authentication and access control
mechanism for all incoming packets.</p>
<p>Capturing the authentication token from an incoming packet can be implemented via the <a href="filters/./capture_bytes.html">CaptureByte</a>
filter, with an example outlined below, or any other filter that populates the configured dynamic metadata key for the
authentication token to reside.</p>
<p>It is assumed that the endpoint tokens that are used for authentication are generated by an external system, are 
appropriately cryptographically random and sent to each proxy securely.</p>
<p>For example, a configuration would look like:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let yaml = &quot;
</span>version: v1alpha1
static:
  filters:
    - name: quilkin.extensions.filters.capture_bytes.v1alpha1.CaptureBytes # Capture and remove the authentication token
      config:
          size: 3
          remove: true
    - name: quilkin.extensions.filters.token_router.v1alpha1.TokenRouter
  endpoints: 
    - address: 127.0.0.1:26000
      metadata:
        quilkin.dev:
          tokens:
            - MXg3aWp5Ng== # Authentication is provided by these ids, and matched against 
            - OGdqM3YyaQ== # the value stored in Filter dynamic metadata
    - address: 127.0.0.1:26001
      metadata:
        quilkin.dev:
          tokens:
            - bmt1eTcweA==
<span class="boring">&quot;;
</span><span class="boring">let config = quilkin::config::Config::from_reader(yaml.as_bytes()).unwrap();
</span><span class="boring">assert_eq!(config.source.get_static_filters().unwrap().len(), 2);
</span><span class="boring">quilkin::Builder::from(std::sync::Arc::new(config)).validate().unwrap();
</span><span class="boring">}
</span></code></pre></pre>
<p>On the game client side the <a href="filters/./concatenate_bytes.html">ConcatenateBytes</a> filter could also be used to add authentication
tokens to outgoing packets.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="firewall"><a class="header" href="#firewall">Firewall</a></h1>
<p>The <code>Firewall</code> filter's job is to allow or block traffic depending on if the incoming traffic's IP and port matches
the rules set on the Firewall filter.</p>
<h4 id="filter-name-7"><a class="header" href="#filter-name-7">Filter name</a></h4>
<pre><code class="language-text">quilkin.extensions.filters.firewall.v1alpha1.Firewall
</code></pre>
<h3 id="configuration-examples-8"><a class="header" href="#configuration-examples-8">Configuration Examples</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let yaml = &quot;
</span>version: v1alpha1
static:
  filters:
    - name: quilkin.extensions.filters.firewall.v1alpha1.Firewall
      config:
        on_read:
          - action: ALLOW
            source: 192.168.51.0/24
            ports:
               - 10
               - 1000-7000
        on_write: 
          - action: DENY
            source: 192.168.51.0/24
            ports:
               - 7000
  endpoints:
    - address: 127.0.0.1:7001
<span class="boring">&quot;;
</span><span class="boring">let config = quilkin::config::Config::from_reader(yaml.as_bytes()).unwrap();
</span><span class="boring">assert_eq!(config.source.get_static_filters().unwrap().len(), 1);
</span><span class="boring">quilkin::Builder::from(std::sync::Arc::new(config)).validate().unwrap();
</span><span class="boring">}
</span></code></pre></pre>
<h3 id="configuration-options-a-hreffiltersapiquilkinfiltersfirewallstructconfightmlrust-doca"><a class="header" href="#configuration-options-a-hreffiltersapiquilkinfiltersfirewallstructconfightmlrust-doca">Configuration Options (<a href="filters/../../api/quilkin/filters/firewall/struct.Config.html">Rust Doc</a>)</a></h3>
<pre><code class="language-yaml">properties:
  on_read:
    '$ref': '#/definitions/rules'
    description: Rules to match against when reading packets to the local listening port.
  on_write:
    type: array
    '$ref': '#/definitions/rules'
    description: Rules to match against when writing packets to the local listening port.

definitions:
  rules:
    type: array
    description: Rules to match against when writing packets to the local listening port.
    items:
      type: object
      properties:
        action:
          type: string
          description: |
            Whether or not a matching Rule should Allow or Deny access
            - DENY: If the rule matches, block the traffic.
            - ALLOW: If the rule matches, allow the traffic through.
          enum: ['ALLOW', 'DENY']
        source:
          type: string
          description: A CIDR network range, either in a v4 or v6 format.
        ports:
          type: array
          description: Array of singular ports or port ranges to match against.
          items:
            type: string
            description: |
              Either in the format of &quot;10&quot; for a singular port or &quot;10-100&quot; for a port range where 
              min is inclusive, and max is exclusive.
      required: ['action', 'source', 'ports']
</code></pre>
<h4 id="rule-evaluation"><a class="header" href="#rule-evaluation">Rule Evaluation</a></h4>
<p>The Firewall filter supports DENY and ALLOW actions for access control. When multiple DENY and ALLOW actions are used 
for a workload at the same time, the evaluation is processed in the order it is configured, with the first matching 
rule deciding if the request is allowed or denied:</p>
<ol>
<li>If a rule action is ALLOW, and it matches the request, then the entire request is allowed.</li>
<li>If a rule action is DENY and it matches the request, then the entire request is denied.</li>
<li>If none of the configured rules match, then the request is denied.</li>
</ol>
<h3 id="metrics-9"><a class="header" href="#metrics-9">Metrics</a></h3>
<ul>
<li><code>quilkin_filter_Firewall_packets_denied_total</code> Total number of packets denied.</li>
<li><code>quilkin_filter_Firewall_packets_allowed_total</code> Total number of packets allowed.</li>
</ul>
<p>Both metrics have the label <code>event</code>, with a value of <code>read</code> or <code>write</code> which corresponds to either <code>on_read</code> or 
<code>on_write</code> events within the Filter.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-custom-filters"><a class="header" href="#writing-custom-filters">Writing Custom Filters</a></h1>
<p>Quilkin provides an extensible implementation of <a href="filters/../filters.html">Filters</a> that allows us to plug in custom implementations to fit our needs.
This document provides an overview of the API and how we can go about writing our own <a href="filters/../filters.html">Filters</a>.</p>
<h2 id="api-components"><a class="header" href="#api-components">API Components</a></h2>
<p>The following components make up Quilkin's implementation of filters.</p>
<h3 id="filter"><a class="header" href="#filter">Filter</a></h3>
<p>A <a href="filters/../../api/quilkin/filters/trait.Filter.html">trait</a> representing an actual <a href="filters/../filters.html#built-in-filters">Filter</a> instance in the pipeline.</p>
<ul>
<li>An implementation provides a <code>read</code> and a <code>write</code> method.</li>
<li>Both methods are invoked by the proxy when it consults the <a href="filters/../filters.html#filters-and-filter-chain">filter chain</a> - their arguments contain information about the packet being processed.</li>
<li><code>read</code> is invoked when a packet is received on the local downstream port and is to be sent to an upstream endpoint while <code>write</code> is invoked in the opposite direction when a packet is received from an upstream endpoint and is to be sent to a downstream client.</li>
</ul>
<h3 id="filterfactory"><a class="header" href="#filterfactory">FilterFactory</a></h3>
<p>A <a href="filters/../../api/quilkin/filters/trait.FilterFactory.html">trait</a> representing a type that knows how to create instances of a particular type of <a href="filters/../../api/quilkin/filters/trait.Filter.html">Filter</a>.</p>
<ul>
<li>An implementation provides a <code>name</code> and <code>create_filter</code> method.</li>
<li><code>create_filter</code> takes in <a href="filters/../filters.html#filter-config">configuration</a> for the filter to create and returns a <a href="filters/../../api/quilkin/filters/prelude/struct.FilterInstance.html">FilterInstance</a> type containing a new instance of its filter type.<br />
<code>name</code> returns the Filter name - a unique identifier of filters of the created type (e.g quilkin.extensions.filters.debug.v1alpha1.Debug).</li>
</ul>
<h3 id="filterregistry"><a class="header" href="#filterregistry">FilterRegistry</a></h3>
<p>A <a href="filters/../../api/quilkin/filters/struct.FilterRegistry.html">struct</a> representing the set of all filter types known to the proxy.
It contains all known implementations of <a href="filters/../../api/quilkin/filters/trait.FilterFactory.html">FilterFactory</a>, each identified by their <a href="filters/../../api/quilkin/filters/trait.FilterFactory.html#tymethod.name">name</a>.</p>
<p>These components come together to form the <a href="filters/../filters.html#filters-and-filter-chain">filter chain</a>.</p>
<ul>
<li>A <a href="filters/../../api/quilkin/filters/struct.FilterRegistry.html">FilterRegistry</a> is populated with the <a href="filters/../../api/quilkin/filters/trait.FilterFactory.html">FilterFactory</a> for <a href="filters/../filters.html#built-in-filters">built-in-filters</a> and any custom ones we provide.</li>
<li>During startup, the initial list of <a href="filters/../filters.html#filter-config">filter configuration</a> is retrieved, either from a <a href="filters/../proxy-configuration.html">static config file</a> or dynamically from a <a href="filters/../xds.html">management server</a>.</li>
<li>Each <a href="filters/../filters.html#filter-config">filter configuration</a> is used to invoke the matching (based on the Filter name) <a href="filters/../../api/quilkin/filters/trait.FilterFactory.html">FilterFactory</a> in the <a href="filters/../../api/quilkin/filters/struct.FilterRegistry.html">FilterRegistry</a> - creating a <a href="filters/../../api/quilkin/filters/trait.Filter.html">Filter</a> instance.</li>
<li>Finally, the created <a href="filters/../../api/quilkin/filters/trait.Filter.html">Filter</a> instances are piped together to form the <a href="filters/../filters.html#filters-and-filter-chain">filter chain</a>.</li>
</ul>
<p>Note that when using dynamic configuration, the process repeats in a similar manner - new filter instances are created according to the updated <a href="filters/../filters.html#filter-config">filter configuration</a> and a new <a href="filters/../filters.html#filters-and-filter-chain">filter chain</a> is re-created while the old one is dropped.</p>
<h3 id="creating-custom-filters"><a class="header" href="#creating-custom-filters">Creating Custom Filters</a></h3>
<p>To extend Quilkin's code with our own custom filter, we need to do the following:</p>
<ol>
<li>Import the Quilkin crate.</li>
<li>Implement the <a href="filters/../../api/quilkin/filters/trait.Filter.html">Filter</a> trait with our custom logic, as well as a <a href="filters/../../api/quilkin/filters/trait.FilterFactory.html">FilterFactory</a> that knows how to create instances of the Filter implementation.</li>
<li>Start the proxy with the custom <a href="filters/../../api/quilkin/filters/trait.FilterFactory.html">FilterFactory</a> implementation.</li>
</ol>
<blockquote>
<p>The full source code used in this example can be found <a href="https://github.com/googleforgames/quilkin/tree/main/examples/quilkin-filter-example">here</a></p>
</blockquote>
<h4 id="1-import-the-quilkin-crate"><a class="header" href="#1-import-the-quilkin-crate">1. Import the Quilkin crate</a></h4>
<pre><code class="language-bash"># Start with a new crate
cargo new --bin quilkin-filter-example
</code></pre>
<p>Add Quilkin as a dependency in <code>Cargo.toml</code>.</p>
<pre><code class="language-toml">[dependencies]
quilkin = &quot;0.2.0&quot;
</code></pre>
<h4 id="2-implement-the-filter-traits"><a class="header" href="#2-implement-the-filter-traits">2. Implement the filter traits</a></h4>
<p>It's not terribly important what the filter in this example does so let's write a <code>Greet</code> filter that appends <code>Hello</code> to every packet in one direction and <code>Goodbye</code> to packets in the opposite direction.</p>
<p>We start with the <a href="filters/../../api/quilkin/filters/trait.Filter.html">Filter</a> implementation</p>
<pre><code class="language-rust no_run noplayground"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">
</span>// src/main.rs
use quilkin::filters::prelude::*;
 
struct Greet;

impl Filter for Greet {
    fn read(&amp;self, mut ctx: ReadContext) -&gt; Option&lt;ReadResponse&gt; {
        ctx.contents.splice(0..0, String::from(&quot;Hello &quot;).into_bytes());
        Some(ctx.into())
    }
    fn write(&amp;self, mut ctx: WriteContext) -&gt; Option&lt;WriteResponse&gt; {
        ctx.contents.splice(0..0, String::from(&quot;Goodbye &quot;).into_bytes());
        Some(ctx.into())
    }
}
<span class="boring">}
</span></code></pre>
<p>Next, we implement a <a href="filters/../../api/quilkin/filters/trait.FilterFactory.html">FilterFactory</a> for it and give it a name:</p>
<pre><code class="language-rust no_run noplayground"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">
</span><span class="boring">struct Greet;
</span><span class="boring">impl Filter for Greet {}
</span><span class="boring">use quilkin::filters::Filter;
</span>// src/main.rs
use quilkin::filters::prelude::*;

pub const NAME: &amp;str = &quot;greet.v1&quot;;

pub fn factory() -&gt; DynFilterFactory {
    Box::from(GreetFilterFactory)
}

struct GreetFilterFactory;
impl FilterFactory for GreetFilterFactory {
    fn name(&amp;self) -&gt; &amp;'static str {
        NAME
    }
    fn create_filter(&amp;self, _: CreateFilterArgs) -&gt; Result&lt;FilterInstance, Error&gt; {
        let filter: Box&lt;dyn Filter&gt; = Box::new(Greet);
        Ok(FilterInstance::new(serde_json::Value::Null, filter))
    }
}
<span class="boring">}
</span></code></pre>
<h4 id="3-start-the-proxy"><a class="header" href="#3-start-the-proxy">3. Start the proxy</a></h4>
<p>We can run the proxy in the exact manner as the default Quilkin binary using the <a href="filters/../../api/quilkin/runner/fn.run.html">run</a> function, passing in our custom <a href="filters/../../api/quilkin/filters/trait.FilterFactory.html">FilterFactory</a>.
Let's add a main function that does that. Quilkin relies on the <a href="https://docs.rs/tokio/1.5.0/tokio/">Tokio</a> async runtime, so we need to import that 
crate and wrap our main function with it.</p>
<p>Add Tokio as a dependency in <code>Cargo.toml</code>.</p>
<pre><code class="language-toml">[dependencies]
quilkin = &quot;0.2.0&quot;
tokio = { version = &quot;1&quot;, features = [&quot;full&quot;]}
</code></pre>
<p>Add a main function that starts the proxy.</p>
<pre><code class="language-rust no_run noplayground ignore">// src/main.rs
#[tokio::main]
async fn main() {
    quilkin::run(vec![self::factory()].into_iter())
        .await
        .unwrap();
}
</code></pre>
<p>Now, let's try out the proxy. The following configuration starts our extended version of the proxy at port 7001 and
forwards all packets to an upstream server at port 4321.</p>
<pre><code class="language-yaml"># config.yaml
version: v1alpha1
proxy:
  port: 7001
static:
  filters:
  - name: greet.v1
  endpoints:
  - address: 127.0.0.1:4321
</code></pre>
<ul>
<li>
<p>Start the proxy</p>
<pre><code class="language-bash">cargo run -- -c config.yaml
</code></pre>
</li>
<li>
<p>Start a UDP listening server on the configured port</p>
<pre><code class="language-bash">nc -lu 127.0.0.1 4321
</code></pre>
</li>
<li>
<p>Start an interactive UDP client that sends packet to the proxy</p>
<pre><code class="language-bash">nc -u 127.0.0.1 7001
</code></pre>
</li>
</ul>
<p>Whatever we pass to the client should now show up with our modification on the listening server's standard output.
For example typing <code>Quilkin</code> in the client prints <code>Hello Quilkin</code> on the server.</p>
<h4 id="4-working-with-filter-configuration"><a class="header" href="#4-working-with-filter-configuration">4. Working with Filter Configuration</a></h4>
<p>Let's extend the <code>Greet</code> filter to require a configuration that contains what greeting to use.</p>
<p>The <a href="https://docs.serde.rs/serde_yaml/index.html">Serde</a> crate is used to describe static YAML configuration in code while <a href="https://docs.rs/prost/0.7.0/prost/">Prost</a> is used to describe dynamic configuration as <a href="https://developers.google.com/protocol-buffers">Protobuf</a> messages when talking to the <a href="filters/../xds.html">management server</a>.</p>
<h5 id="static-configuration"><a class="header" href="#static-configuration">Static Configuration</a></h5>
<p>First let's create the config for our static configuration:</p>
<h6 id="1-add-the-yaml-parsing-crates-to-cargotoml"><a class="header" href="#1-add-the-yaml-parsing-crates-to-cargotoml">1. Add the yaml parsing crates to <code>Cargo.toml</code>:</a></h6>
<pre><code class="language-toml">  [dependencies]
  # ...
  serde = &quot;1.0&quot;
  serde_yaml = &quot;0.8&quot;
</code></pre>
<h6 id="2-define-a-struct-representing-the-config"><a class="header" href="#2-define-a-struct-representing-the-config">2. Define a struct representing the config:</a></h6>
<pre><code class="language-rust no_run noplayground ignore">// src/main.rs
#[derive(Serialize, Deserialize, Debug)]
struct Config {
    greeting: String,
}
</code></pre>
<h6 id="3-update-the-greet-filter-to-take-in-greeting-as-a-parameter"><a class="header" href="#3-update-the-greet-filter-to-take-in-greeting-as-a-parameter">3. Update the <code>Greet</code> Filter to take in <code>greeting</code> as a parameter:</a></h6>
<pre><code class="language-rust no_run noplayground ignore">// src/main.rs
struct Greet(String);

impl Filter for Greet {
    fn read(&amp;self, mut ctx: ReadContext) -&gt; Option&lt;ReadResponse&gt; {
        ctx.contents
            .splice(0..0, format!(&quot;{} &quot;, self.0).into_bytes());
        Some(ctx.into())
    }
    fn write(&amp;self, mut ctx: WriteContext) -&gt; Option&lt;WriteResponse&gt; {
        ctx.contents
            .splice(0..0, format!(&quot;{} &quot;, self.0).into_bytes());
        Some(ctx.into())
    }
}
</code></pre>
<h6 id="4-finally-update-greetfilterfactory-to-extract-the-greeting-from-the-passed-in-configuration-and-forward-it-onto-the-greet-filter"><a class="header" href="#4-finally-update-greetfilterfactory-to-extract-the-greeting-from-the-passed-in-configuration-and-forward-it-onto-the-greet-filter">4. Finally, update <code>GreetFilterFactory</code> to extract the greeting from the passed in configuration and forward it onto the <code>Greet</code> Filter.</a></h6>
<pre><code class="language-rust no_run noplayground">// src/main.rs
<span class="boring">use serde::{Deserialize, Serialize};
</span><span class="boring">#[derive(Serialize, Deserialize, Debug)]
</span><span class="boring">struct Config {
</span><span class="boring">    greeting: String,
</span><span class="boring">}
</span><span class="boring">use quilkin::filters::prelude::*;
</span><span class="boring">struct Greet(String);
</span><span class="boring">impl Filter for Greet { }
</span>use quilkin::config::ConfigType;

pub const NAME: &amp;str = &quot;greet.v1&quot;;

pub fn factory() -&gt; DynFilterFactory {
    Box::from(GreetFilterFactory)
}

struct GreetFilterFactory;
impl FilterFactory for GreetFilterFactory {
    fn name(&amp;self) -&gt; &amp;'static str {
        NAME
    }
    fn create_filter(&amp;self, args: CreateFilterArgs) -&gt; Result&lt;FilterInstance, Error&gt; {
        let config = match args.config.unwrap() {
          ConfigType::Static(config) =&gt; {
              serde_yaml::from_str::&lt;Config&gt;(serde_yaml::to_string(config).unwrap().as_str())
                .unwrap()
          }
          ConfigType::Dynamic(_) =&gt; unimplemented!(&quot;dynamic config is not yet supported for this filter&quot;),
        };
        let filter: Box&lt;dyn Filter&gt; = Box::new(Greet(config.greeting));
        Ok(FilterInstance::new(serde_json::Value::Null, filter))
    }
}
</code></pre>
<p>And with these changes we have wired up static configuration for our filter. Try it out with the following config.yaml:</p>
<pre><code class="language-yaml"># config.yaml
version: v1alpha1
proxy:
  port: 7001
static:
  filters:
  - name: greet.v1
    config:
      greeting: Hey
  endpoints:
  - address: 127.0.0.1:4321
</code></pre>
<h5 id="dynamic-configuration"><a class="header" href="#dynamic-configuration">Dynamic Configuration</a></h5>
<p>You might have noticed while adding <a href="filters/writing_custom_filters.html#static-configuration">static configuration support</a>, that the <a href="filters/../../api/quilkin/filters/prelude/struct.CreateFilterArgs.html#structfield.config">config</a> argument passed into our <a href="filters/../../api/quilkin/filters/trait.FilterFactory.html">FilterFactory</a>
has a <a href="filters/../../api/quilkin/config/enum.ConfigType.html#variant.Dynamic">Dynamic</a> variant.</p>
<pre><code class="language-rust ignore">let config = match args.config.unwrap() {
    ConfigType::Static(config) =&gt; {
        serde_yaml::from_str::&lt;Config&gt;(serde_yaml::to_string(config).unwrap().as_str())
         .unwrap()
    }
    ConfigType::Dynamic(_) =&gt; unimplemented!(&quot;dynamic config is not yet supported for this filter&quot;),
};
</code></pre>
<p>The <a href="filters/../../api/quilkin/config/enum.ConfigType.html#variant.Dynamic">Dynamic</a> contains the serialized <a href="https://developers.google.com/protocol-buffers">Protobuf</a> message received from the <a href="filters/../xds.html">management server</a> for the <a href="filters/../../api/quilkin/filters/trait.Filter.html">Filter</a> to create.
As a result, its contents are entirely opaque to Quilkin and it is represented with the <a href="https://docs.rs/prost-types/0.7.0/prost_types/struct.Any.html">Prost Any</a> type so the <a href="filters/../../api/quilkin/filters/trait.FilterFactory.html">FilterFactory</a>
can interpret its contents however it wishes.<br />
However, it usually contains a Protobuf equivalent of the filter's static configuration.</p>
<h6 id="1-add-the-proto-parsing-crates-to-cargotoml"><a class="header" href="#1-add-the-proto-parsing-crates-to-cargotoml">1. Add the proto parsing crates to <code>Cargo.toml</code>:</a></h6>
<pre><code class="language-toml">[dependencies]
# ...
tonic = &quot;0.5.0&quot;
prost = &quot;0.7&quot;
prost-types = &quot;0.7&quot;
</code></pre>
<h6 id="2-create-a-a-hrefhttpsdevelopersgooglecomprotocol-buffersprotobufa-equivalent-of-the-a-hreffilterswriting_custom_filtershtmlstatic-configurationstatic-configurationa"><a class="header" href="#2-create-a-a-hrefhttpsdevelopersgooglecomprotocol-buffersprotobufa-equivalent-of-the-a-hreffilterswriting_custom_filtershtmlstatic-configurationstatic-configurationa">2. Create a <a href="https://developers.google.com/protocol-buffers">Protobuf</a> equivalent of the <a href="filters/writing_custom_filters.html#static-configuration">static configuration</a>:</a></h6>
<pre><code class="language-plaintext no_run noplayground ignore">// src/greet.proto
syntax = &quot;proto3&quot;;

package greet;

message Greet {
  string greeting = 1;
}
</code></pre>
<h6 id="3-generate-rust-code-from-the-proto-file"><a class="header" href="#3-generate-rust-code-from-the-proto-file">3. Generate Rust code from the proto file:</a></h6>
<p>There are a few ways to generate <a href="https://docs.rs/prost/0.7.0/prost/">Prost</a> code from proto, we will use the <a href="https://docs.rs/prost-build/0.7.0/prost_build/">prost_build</a> crate in this example.</p>
<p>Add the required crates to <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
# ...
bytes = &quot;1.0&quot;

[build-dependencies]
prost-build = &quot;0.7&quot;
</code></pre>
<p>Add a <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">build script</a> to generate the Rust code during compilation:</p>
<pre><code class="language-rust no_run noplayground ignore">// src/build.rs
fn main() {
    prost_build::compile_protos(&amp;[&quot;src/greet.proto&quot;], &amp;[&quot;src/&quot;]).unwrap();
}
</code></pre>
<p>To include the generated code, we'll use a convenience macro <a href="filters/../../api/quilkin/macro.include_proto.html">include_proto</a>, which imports the generated code, while
recreating the grpc package name as Rust modules:</p>
<pre><code class="language-rust no_run noplayground ignore">// src/main.rs
quilkin::include_proto!(&quot;greet&quot;);
use greet::Greet as ProtoGreet;
</code></pre>
<h6 id="4-decode-the-serialized-proto-message-into-a-config"><a class="header" href="#4-decode-the-serialized-proto-message-into-a-config">4. Decode the serialized proto message into a config:</a></h6>
<p>If the message contains a Protobuf equivalent of the filter's static configuration, we can
leverage the <a href="filters/../../api/quilkin/config/enum.ConfigType.html#method.deserialize">deserialize</a> method to deserialize either a static or dynamic config. 
The function automatically deserializes and converts from the Protobuf type if the input contains a dynamic
configuration.<br />
As a result, the function requires that the <a href="https://doc.rust-lang.org/std/convert/trait.TryFrom.html">std::convert::TryFrom</a> is implemented from our dynamic
config type to a static equivalent.</p>
<pre><code class="language-rust no_run noplayground ignore">// src/main.rs
impl TryFrom&lt;ProtoGreet&gt; for Config {
    type Error = ConvertProtoConfigError;

    fn try_from(p: ProtoGreet) -&gt; Result&lt;Self, Self::Error&gt; {
        Ok(Config {
            greeting: p.greeting,
        })
    }
}
</code></pre>
<p>With our conversion implementation, we can to extract a greeting from any configuration type and
forward it onto the <code>Greet</code> Filter.</p>
<pre><code class="language-rust no_run noplayground ignore">// src/main.rs
pub const NAME: &amp;str = &quot;greet.v1&quot;;

pub fn factory() -&gt; DynFilterFactory {
    Box::from(GreetFilterFactory)
}

struct GreetFilterFactory;
impl FilterFactory for GreetFilterFactory {
    fn name(&amp;self) -&gt; &amp;'static str {
        NAME
    }
    fn create_filter(&amp;self, args: CreateFilterArgs) -&gt; Result&lt;FilterInstance, Error&gt; {
        let (config_json, config) = self
            .require_config(args.config)?
            .deserialize::&lt;Config, ProtoGreet&gt;(self.name())?;
        let filter: Box&lt;dyn Filter&gt; = Box::new(Greet(config.greeting));
        Ok(FilterInstance::new(config_json, filter))
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quilkin-integration-examples"><a class="header" href="#quilkin-integration-examples">Quilkin Integration Examples</a></h1>
<p>The Quilkin proxy can be integrated with your dedicated game servers in several ways,
each providing different capabilities and complexity tradeoffs.</p>
<p>Below captures several of the most useful and prevalent architectural patterns to give you inspiration
on how you can use Quilkin in your multiplayer game networking architecture.</p>
<h2 id="server-proxy-as-a-sidecar"><a class="header" href="#server-proxy-as-a-sidecar">Server Proxy as a Sidecar</a></h2>
<pre><code class="language-text">                  +
                  |
               Internet
                  |
                  |
                  |
+---------+       |          +----------------+ +----------------+
|  Game   |       |          | Quilkin        | | Dedicated      |
|  Client &lt;------------------&gt; (Server Proxy) | | Game Server    |
+---------+       |          |                &lt;-&gt;                |
                  |          +----------------+ +----------------+
                  |
                  |
                  |          +----------------+ +----------------+
                  |          | Quilkin        | | Dedicated      |
                  |          | (Server Proxy) | | Game Server    |
                  |          |                &lt;-&gt;                |
                  |          +----------------+ +----------------+
                  |
                  |
                  |
                  +
</code></pre>
<p>This is the simplest integration and configuration option with Quilkin, but does provide the smallest number
of possible feature implementations and ability to provide redundancy.</p>
<p>That being said, this is a low risk way to integrate Quilkin, and take advantage of the out-of-the-box telemetry
and metric information that comes with Quilkin.</p>
<ul>
<li>In this example, the Server proxy is running alongside the dedicated game server - on the same public IP/machine/container.
<ul>
<li>This is often referred to as a sidecar pattern.</li>
</ul>
</li>
<li>Communication between the Server Proxy and the Dedicated Game Server occurs over the localhost network, with a
separate port for each Game Client connection.</li>
<li>Clients connect to the Server Proxy's public port/IP combination, and the Server Proxy routes all traffic directly
to the dedicated game server.</li>
<li>The Server Proxy can still use filters such as rate limiting, compression (forthcoming) or encryption (forthcoming),
as long as the Game Client conforms to the standard protocols utilised by those filters as appropriate.</li>
</ul>
<h2 id="client-proxy-to-sidecar-server-proxy"><a class="header" href="#client-proxy-to-sidecar-server-proxy">Client Proxy to Sidecar Server Proxy</a></h2>
<pre><code class="language-text">                                    +
                                    |
                                 Internet
                                    |
                                    |
                                    |
+---------+    +----------------+   |        +----------------+ +----------------+
|  Game   |    | Quilkin        |   |        | Quilkin        | | Dedicated      |
|  Client &lt;----&gt; (Client Proxy) &lt;------------&gt; (Server Proxy) | | Game Server    |
+---------+    +----------------+   |        |                &lt;-&gt;                |
                                    |        +----------------+ +----------------+
                                    |
                                    |
                                    |        +----------------+ +----------------+
                                    |        | Quilkin        | | Dedicated      |
                                    |        | (Server Proxy) | | Game Server    |
                                    |        |                &lt;-&gt;                |
                                    |        +----------------+ +----------------+
                                    |
                                    |
                                    |
                                    +
</code></pre>
<p>This example is the same as the above, but puts a Client Proxy between the Game Client, and the Server Proxy to take
advantage of Client Proxy functionality.</p>
<ul>
<li>The Client Proxy may be integrated as a standalone binary, or directly into the client, with communication
occurring over a localhost port.</li>
<li>The Client Proxy can now utilise filters, such as, compression (forthcoming) and encryption (forthcoming), without
having to change the Game Client.</li>
<li>The Game Client will need to communicate to the Client Proxy what IP it should connect to when the Client is 
match-made with a Game Server.</li>
</ul>
<h2 id="client-proxy-to-separate-server-proxies-pools"><a class="header" href="#client-proxy-to-separate-server-proxies-pools">Client Proxy to Separate Server Proxies Pools</a></h2>
<pre><code class="language-text">                                       +                          +
                                       |                          |
                                    Internet                   Private
                                       |                       Network
                                       |     +----------------+   |          +----------------+
                                       |     | Quilkin        |   |          | Dedicated      |
                                       |  +--&gt; (Server Proxy) &lt;-------+------&gt; Game Server    |
+---------+      +----------------+    |  |  |                |   |   |      |                |
|  Game   |      | Quilkin        &lt;-------+  +----------------+   |   |      +----------------+
|  Client &lt;------&gt; (Client Proxy) |    |  |                       |   |
+---------+      +----------------+    |  |  +----------------+   |   |      +----------------+
                                       |  |  | Quilkin        |   |   |      | Dedicated      |
                                       |  +--&gt; (Server Proxy) &lt;-------+      | Game Server    |
                                       |     |                |   |          |                |
                                       |     +----------------+   |          +----------------+
                                       |                          |
                                       |     +----------------+   |          +----------------+
                                       |     | Quilkin        |   |          | Dedicated      |
                                       |     | (Server Proxy) |   |          | Game Server    |
                                       |     |                |   |          |                |
                                       |     +----------------+   |          +----------------+
                                       +                          +

</code></pre>
<p>This is the most complex configuration, but enables the most reuse of Quilkin's functionality,
while also providing the most redundancy and security for your dedicated game servers.</p>
<ul>
<li>The Game client sends and receives packets from the Quilkin client proxy.</li>
<li>The Client Proxy may be integrated as a standalone binary, or directly into the client, with communication
occurring over a localhost port.</li>
<li>The Client Proxy can utilise the full set of filters, such as routing, compression (forthcoming) and
encryption (forthcoming), without having to change the Game Client.</li>
<li>There are a hosted set of Quilkin Server proxies that have public IP addresses, and are connected
to a <a href="https://github.com/googleforgames/quilkin/issues/131">control plane</a> to coordinate routing and access control
to the dedicated game servers, which are on private IP addresses.</li>
<li>The Client Proxy is made aware of one or more Server proxies to connect to, possibly via their Game Client matchmaker
or another service, with an authentication token to pass to the Server proxies, such that the UDP packets can be
routed correctly to the dedicated game server they should connect to.</li>
<li>Dedicated game servers receive traffic as per normal from the Server Proxies, and send data back to the proxies
directly.</li>
<li>If the dedicated game server always expects traffic from only a single ip/port combination for client connection, 
then traffic will always need to be sent through a single Server Proxy. Otherwise, UDP packets can be load
balanced via the Client Proxy to multiple Server Proxies for even greater redundancy.</li>
</ul>
<h2 id="what-next-1"><a class="header" href="#what-next-1">What Next?</a></h2>
<ul>
<li>Have a look at the <a href="https://github.com/googleforgames/quilkin/blob/main/examples">example configurations</a> for basic configuration examples.</li>
<li>Review the <a href="./filters.html">set of filters</a> that are available.</li>
</ul>
<hr />
<p>Diagrams powered by http://asciiflow.com/</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="administration-interface"><a class="header" href="#administration-interface">Administration Interface</a></h1>
<p>Quilkin exposes an HTTP interface to query different aspects of the server.</p>
<blockquote>
<p>It is assumed that the administration interface will only ever be able to be accessible on <code>localhost</code>.</p>
</blockquote>
<p>By default, the administration interface is bound to <code>[::]:9091</code>, but it can be configured through the 
<a href="./proxy-configuration.html">proxy configuration file</a>, like so:</p>
<pre><code class="language-yaml">admin:
  address: [::]:9095
</code></pre>
<p>The admin interface provides the following endpoints:</p>
<h2 id="live"><a class="header" href="#live">/live</a></h2>
<p>This provides a liveness probe endpoint, most commonly used in 
<a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-a-liveness-command">Kubernetes based systems</a>.</p>
<p>Will return an HTTP status of 200 when all health checks pass.</p>
<h2 id="metrics-10"><a class="header" href="#metrics-10">/metrics</a></h2>
<p>Outputs <a href="https://prometheus.io/">Prometheus</a> formatted metrics for this proxy.</p>
<p>See the <a href="./proxy.html#metrics">Proxy Metrics</a> documentation for what metrics are available.</p>
<h2 id="config"><a class="header" href="#config">/config</a></h2>
<p>Returns a JSON representation of the cluster and filterchain configuration that the proxy is running
with at the time of invocation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<h2 id="just-how-fast-is-quilkin-what-sort-of-performance-can-i-expect"><a class="header" href="#just-how-fast-is-quilkin-what-sort-of-performance-can-i-expect">Just how fast is Quilkin? What sort of performance can I expect?</a></h2>
<p>Our current testing shows that on Quilkin shows that it process packets <em>quite fast</em>!</p>
<p>We won't be publishing performance benchmarks, as performance will always
change depending on the underlying hardware, number of filters, configurations and more.</p>
<p>We highly recommend you run your own load tests on your platform and configuration, matching your production 
workload and configuration as close as possible. </p>
<p>Our <a href="https://iperf.fr/">iperf3</a> based performance test in the
<a href="https://github.com/googleforgames/quilkin/tree/main/examples/iperf3">examples' folder</a> is a good starting point.</p>
<p>Since this is still an alpha project, we have plans on investigating further performance improvements in upcoming 
releases, both from an optimisation and observability perspective as well.</p>
<h2 id="can-i-integrate-quilkin-with-c-code"><a class="header" href="#can-i-integrate-quilkin-with-c-code">Can I integrate Quilkin with C++ code?</a></h2>
<p>Quilkin is also released as a <a href="https://crates.io/crates/quilkin">library</a>, so it can be integrated with an external 
codebase as necessary.</p>
<p>Using Rust code inside a C or C++ project mostly consists of two parts.</p>
<ul>
<li>Creating a C-friendly API in Rust</li>
<li>Embedding your Rust project into an external build system</li>
</ul>
<p>See <a href="https://docs.rust-embedded.org/book/interoperability/rust-with-c.html">A little Rust with your C</a> for more 
information.</p>
<p>Over time, we will be expanding documentation on how to integrate with specific engines if running Quilkin as a 
separate binary is not an option.</p>
<h2 id="i-would-like-to-run-quilkin-as-a-client-side-proxy-on-a-console-can-i-do-that"><a class="header" href="#i-would-like-to-run-quilkin-as-a-client-side-proxy-on-a-console-can-i-do-that">I would like to run Quilkin as a client side proxy on a console? Can I do that?</a></h2>
<p>This is an ongoing discussion, and since console development is protected by non-disclosure agreements, we can't 
comment on this directly.</p>
<p>That being said, we are having discussions on how we can release lean versions of certain filters that would work 
with known supported game engines and languages for circumstances where compiling Rust or providing a separate 
Quilkin binary as an executable is not an option.</p>
<h2 id="any-reason-you-didnt-contribute-this-intoextend-envoy"><a class="header" href="#any-reason-you-didnt-contribute-this-intoextend-envoy">Any reason you didn't contribute this into/extend Envoy?</a></h2>
<p>This is an excellent question! <a href="https://www.envoyproxy.io/">Envoy</a> is an amazing project, and has set many of the 
standards for how <a href="./xds.html">proxies are written and orchestrated</a>, and was an inspiration for many of 
the decisions made on Quilkin.</p>
<p>However, we decided to build this project separately:</p>
<ul>
<li>Envoy seems primarily focused on web/mobile network workloads (which makes total sense), whereas we wanted 
something specialised on gaming UDP communication, so having a leaner, more focused codebase would allow us to move 
faster.</li>
<li>We found the Rust and Cargo ecosystem easier to work with than Bazel and C++, and figured our users would as well.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="dynamic-configuration-using-xds-management-servers"><a class="header" href="#dynamic-configuration-using-xds-management-servers">Dynamic Configuration using xDS Management Servers</a></h3>
<p>In addition to static configuration provided upon startup, a Quiklin proxy's configuration can also be updated at runtime. The proxy can be configured on startup to talk to a set of management servers which provide it with updates throughout its lifecycle.</p>
<p>Communication between the proxy and management server uses the <a href="https://www.envoyproxy.io/docs/envoy/latest/api-docs/xds_protocol#xds-rest-and-grpc-protocol">xDS gRPC protocol</a>, similar to an <a href="https://www.envoyproxy.io/docs/envoy/latest/">envoy proxy</a>. xDS is one of the standard configuration mechanisms for software proxies and as a result, Quilkin can be setup to discover configuration resources from any API compatible server. Also, given that the protocol is <a href="https://www.envoyproxy.io/docs/envoy/latest/api-docs/xds_protocol#the-xds-transport-protocol">well specified</a>, it is similarly straight-forward to implement a custom server to suit any deployment's needs.</p>
<blockquote>
<p>The <a href="https://github.com/envoyproxy/go-control-plane">go-control-plane</a> project provides production ready implementations of the API on top of which custom servers can be built relatively easily.</p>
</blockquote>
<p>As described within the <a href="https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/operations/dynamic_configuration">xDS-api</a> documentation, the xDS API comprises a set of resource discovery APIs, each serving a specific set of configuration resource types, while the protocol itself comes in several <a href="https://www.envoyproxy.io/docs/envoy/latest/api-docs/xds_protocol#variants-of-the-xds-transport-protocol">variants</a>.
Quilkin implements the <strong>Aggregated Discovery Service (ADS)</strong> <em>State of the World (SotW)</em> variant with gRPC.</p>
<h4 id="supported-apis"><a class="header" href="#supported-apis">Supported APIs</a></h4>
<p>Since the range of resources configurable by the xDS API extends that of Quilkin's domain (i.e being UDP based, Quilkin does not have a need for HTTP/TCP resources), only a subset of the API is supported. The following lists these relevant parts and any limitation to the provided support as a result:</p>
<ul>
<li>
<p><strong>Cluster Discovery Service <a href="https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/operations/dynamic_configuration#cds">(CDS)</a></strong>: Provides information about known clusters and their membership information.</p>
<ul>
<li>The proxy uses these resources to discover clusters and their endpoints.</li>
<li>While cluster topology information like <a href="https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/base.proto#config-core-v3-locality">locality</a> can be provided in the configuration, the proxy currently does not use this information (support may be included in the future however).</li>
<li>Any <a href="https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#enum-config-cluster-v3-cluster-lbpolicy">load balancing information</a> included in this resource is ignored. For load balancing, use <a href="./filters.html">Quilkin filters</a> instead.</li>
<li>Only <a href="https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#enum-config-cluster-v3-cluster-discoverytype">cluster discovery type</a> <code>STATIC</code> and <code>EDS</code> is supported. Configuration including other discovery types e.g <code>LOGICAL_DNS</code> is rejected.</li>
</ul>
</li>
<li>
<p><strong>Endpoint Discovery Service <a href="https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/operations/dynamic_configuration#eds">(EDS)</a></strong>: Provides information about endpoints.</p>
<ul>
<li>The proxy uses these resources to discover information about endpoints like their IP addresses.</li>
<li>Endpoints may provide <a href="./proxy.html#endpoint-metadata">Endpoint Metadata</a> via the <a href="https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/base.proto#envoy-v3-api-msg-config-core-v3-metadata">metadata</a> field. These metadata will be visible to filters as part of the corresponding endpoints information when processing packets.</li>
<li>Only <a href="https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/address.proto#config-core-v3-address">socket addresses</a> are supported on an endpoint's address configuration - i.e an IP address and port number combination. Configuration including any other type of addressing e.g named pipes will be rejected.</li>
<li>Any <a href="https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/endpoint/v3/endpoint.proto#config-endpoint-v3-clusterloadassignment-policy">load balancing information</a> included in this resource is ignored. For load balancing, use <a href="./filters.html">Quilkin filters</a> instead.</li>
</ul>
</li>
<li>
<p><strong>Listener Discovery Service <a href="https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/operations/dynamic_configuration#lds">(LDS)</a></strong>: Provides information about <a href="./filters.html">Filters and Filter Chains</a>.</p>
<ul>
<li>Only the <code>name</code> and <code>filter_chains</code> fields in the <a href="https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/listener/v3/listener.proto#config-listener-v3-listener">Listener resource</a> are used by the proxy. The rest are ignored.</li>
<li>Since Quilkin only uses one filter chain per proxy, at most one filter chain can be provided in the resource. Otherwise the configuration is rejected.</li>
<li>Only the list of <a href="https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/listener/v3/listener_components.proto#envoy-v3-api-msg-config-listener-v3-filter">filters</a> specified in the <a href="https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/listener/v3/listener_components.proto#config-listener-v3-filterchain">filter chain</a> is used by the proxy - i.e other fields like <code>filter_chain_match</code> are ignored. This list also specifies the order that the corresponding filter chain will be constructed.</li>
<li>gRPC proto configuration for Quilkin's built-in filters <a href="https://github.com/googleforgames/quilkin/tree/main/proto/quilkin/extensions/filters">can be found here</a>. They are equivalent to the filter's static configuration.</li>
</ul>
</li>
</ul>
<h4 id="metrics-11"><a class="header" href="#metrics-11">Metrics</a></h4>
<p>Quilkin exposes the following metrics around the management servers and its resources:</p>
<ul>
<li>
<p><code>quilkin_xds_connected_state</code> (Gauge)</p>
<p>A boolean that indicates whether or not the proxy is currently connected to a management server. A value <code>1</code> means that the proxy is connected while <code>0</code> means that it is not connected to any server at that point in time.</p>
</li>
<li>
<p><code>quilkin_xds_update_attempt_total</code> (Counter)</p>
<p>The total number of attempts made by a management server to configure the proxy. This is equivalent to the total number of configuration updates received by the proxy from a management server.</p>
</li>
<li>
<p><code>quilkin_xds_update_success_total</code> (Counter)</p>
<p>The total number of successful attempts made by a management server to configure the proxy. This is equivalent to the total number of configuration updates received by the proxy from a management server and was successfully applied by the proxy.</p>
</li>
<li>
<p><code>quilkin_xds_update_failure_total</code> (Counter)</p>
<p>The total number of unsuccessful attempts made by a management server to configure the proxy. This is equivalent to the total number of configuration updates received by the proxy from a management server and was rejected by the proxy (e.g due to a bad/inconsistent configuration).</p>
</li>
<li>
<p><code>quilkin_xds_requests_total</code> (Counter)</p>
<p>The total number of <a href="https://www.envoyproxy.io/docs/envoy/latest/api-v2/api/v2/discovery.proto#envoy-api-msg-discoveryrequest">DiscoveryRequest</a>s made by the proxy to management servers. This tracks messages flowing in the direction from the proxy to the management server.</p>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
